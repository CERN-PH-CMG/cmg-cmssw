#include "TauElePlotter.h"
#include <THStack.h>
#include <TString.h>
#include <TVector3.h>
#include <TLorentzVector.h>
#include <TLegend.h>
#include <TLine.h>
#include <TVectorD.h>
#include <TLatex.h>
#include <TText.h>
#include <TPaveText.h>
#include "CMGTools/H2TauTau/interface/QCDEstimate.h"

#include "RooDataHist.h"
#include "RooHistPdf.h"
#include "RooHistPdf.h"
#include "RooRealVar.h"
#include "RooAddPdf.h"
#include "RooDataSet.h"
#include "RooChi2Var.h"
#include "RooMinuit.h"
using namespace RooFit;

TauElePlotter::TauElePlotter():
  TNamed("","")
{
}

TauElePlotter::TauElePlotter(const char * name):
  TNamed(name,name),
  smearHistoRes_(0.),
  Chcat_(-1),
  Isocat_(-1),
  MTcat_(-1),
  SMcat_(-1),
  extrasel_("1"),
  blindsel_("1"),
  plotvar_("ditaumass"),
  nbins_(100),
  xmin_(0.),
  xmax_(1000.),
  QCDOStoSSRatio_(1.11),
  QCDMuIsoSideRatio_(0.),
  ZTTType_(1),
  WJetsType_(0),
  MSSMFlag_(0),
  nbinsVariable_(0),
  xbinsVariable_(0)
{
 

  //after sync
  qcdTauIsoRatio_ = "((20<taujetpt&&taujetpt<=25)*2.85+(25<taujetpt&&taujetpt<=30)*1+(30<taujetpt&&taujetpt<=35)*0.411+(35<taujetpt&&taujetpt<=40)*0.196+(40<taujetpt&&taujetpt<=45)*0.109+(45<taujetpt&&taujetpt<=50)*0.0644+(50<taujetpt&&taujetpt<=55)*0.0458+(55<taujetpt&&taujetpt<=60)*0.0349+(60<taujetpt&&taujetpt<=65)*0.0338)";
  qcdMuIsoRatio_  = "((17<mujetpt&&mujetpt<=22)*1.51+(22<mujetpt&&mujetpt<=27)*0.462+(27<mujetpt&&mujetpt<=32)*0.2+(32<mujetpt&&mujetpt<=37)*0.12+(37<mujetpt&&mujetpt<=42)*0.101+(42<mujetpt&&mujetpt<=47)*0.0964+(47<mujetpt&&mujetpt<=52)*0.14+(52<mujetpt&&mujetpt<=57)*0.116)";


  //after sync
  wjetsTauIsoRatio_ = "((20<taujetpt&&taujetpt<=25)*3.82+(25<taujetpt&&taujetpt<=30)*1.3+(30<taujetpt&&taujetpt<=35)*0.502+(35<taujetpt&&taujetpt<=40)*0.256+(40<taujetpt&&taujetpt<=45)*0.144+(45<taujetpt&&taujetpt<=50)*0.0986+(50<taujetpt&&taujetpt<=55)*0.0736+(55<taujetpt&&taujetpt<=60)*0.0546+(60<taujetpt&&taujetpt<=65)*0.0477+(65<taujetpt&&taujetpt<=70)*0.0365+(70<taujetpt&&taujetpt<=75)*0.0341+(75<taujetpt&&taujetpt<=80)*0.0271+(80<taujetpt&&taujetpt<=85)*0.024+(85<taujetpt&&taujetpt<=90)*0.0212+(90<taujetpt&&taujetpt<=95)*0.0192+(95<taujetpt&&taujetpt<=100)*0.0163)";


}

TauElePlotter::~TauElePlotter(){
}

/////////////General methods start here

bool TauElePlotter::scaleSamplesLumi(){
  
  //reset all scales
  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
    (*s)->resetScale();
  


  /////////determine total lumi and scale MCs
  float totalDataLumi=getTotalDataLumi();

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
    if((*s)->getDataType()=="MC" 
       || (*s)->getDataType()=="MCCat" 
       || (*s)->getDataType()=="Signal" ){
      //cout<<(*s)->GetName()<<" lumi scale "<<totalDataLumi/(*s)->getLumi()<<endl;
      (*s)->scale(totalDataLumi/(*s)->getLumi());
    }



  ///////////////////////////////////
  ////Scale the embedded samples at inclusive level:  Should there be separate scale factor for OS and SS ? --> should be Ok. ZTauTau is small in SS
  /////////////////////////////////
  cout<<"---------> Scaling Embedded samples "<<endl;
  TString sel="eventweight*(categoryIso==1&&abs(ditaucharge)==0&&1.<ditaumass&&ditaumass<1000.)";
  TH1F*hZTTMC=findSample("ZToTauTau")->getHistoNtpFile("ditaumass",10,1,1001,sel);
  Float_t ZToTauTauMC=hZTTMC->Integral();
  delete hZTTMC;
  Float_t EmbeddedOS=0.;
  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="Embedded"){
      TH1F*hEmbedded=findSample((*s)->GetName())->getHistoNtpFile("ditaumass",10,1,1001,sel);
      EmbeddedOS+=hEmbedded->Integral();
      delete hEmbedded;
    }
  }
  cout<<"ZToTauTauMC= "<<ZToTauTauMC<<" EmbeddedOS="<<EmbeddedOS<<endl;
  if(ZToTauTauMC==0. || EmbeddedOS==0. || ZToTauTauMC!=ZToTauTauMC || EmbeddedOS!=EmbeddedOS){
    cout<<"ERROR---------------->Bad ZToTauTauMC or EmbeddedOS yields: ZToTauTauMC="<<ZToTauTauMC<<" EmbeddedOS="<<EmbeddedOS<<endl;
  } else {
    cout<<"Rescaling Embedded samples by factor : "<<ZToTauTauMC/EmbeddedOS<<endl;
    for(std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
      if((*s)->getDataType()=="Embedded") (*s)->scale(ZToTauTauMC/EmbeddedOS);
  }



  return 1;
}


TH1F* TauElePlotter::getSample(TString samplename){

  TString sel="eventweight";
  if(Chcat_==1) sel += TString("*(abs(ditaucharge)==0)");
  if(Chcat_==2) sel += TString("*(abs(ditaucharge)==2)");
  if(Isocat_>0) sel += TString("*(categoryIso==")+(long)Isocat_+")";
  if(MTcat_==1)  sel += "*(transversemass<30)";
  if(MTcat_==3)  sel += "*(transversemass>70)";
  if(MTcat_==13)  sel += "*(60<transversemass&&transversemass<120)";
  if(extrasel_.CompareTo("1")!=0)sel += TString("*")+extrasel_;


  TH1F* h=getPlotHisto(samplename);

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
    if(TString((*s)->GetName())==samplename){

      if(MSSMFlag_ && (*s)->getDataType()=="Signal"){
	//apply generator mass cut
	char cuttxt[100];
	sprintf(cuttxt,"*(%.3f<genbosonmass&&genbosonmass<%.3f)",0.7*((*s)->getSignalMass()),1.3*((*s)->getSignalMass()));
	sel += cuttxt;
	cout<<" applying genbosonmass cut "<<cuttxt<<endl;
      }
      

      TH1F*hd=0;
      if(nbins_>0) hd=(*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      else if(nbinsVariable_>0) hd=(*s)->getHistoNtpFile(plotvar_,nbinsVariable_,xbinsVariable_,sel);
      else { cout<<"binning not recognized "<<endl; return 0;}
      h->Add(hd);
      delete hd;
    }  

  //cout<<" getSample: "<<samplename<<" : "<<h->Integral()<<endl;
  return h;
}



TH1F* TauElePlotter::getTotalData(){
  TString sel="eventweight";
  if(Chcat_==1) sel += TString("*(abs(ditaucharge)==0)");
  if(Chcat_==2) sel += TString("*(abs(ditaucharge)==2)");
  if(Isocat_>0)  sel += TString("*(categoryIso==")+(long)Isocat_+")";
  if(MTcat_==1)  sel += "*(transversemass<30)";
  if(MTcat_==3)  sel += "*(70<transversemass&&transversemass<150)";
  if(MTcat_==13)  sel += "*(60<transversemass&&transversemass<120)";
  if(extrasel_.CompareTo("1")!=0)sel += TString("*")+extrasel_;
  if(blindsel_.CompareTo("1")!=0)sel += TString("*")+blindsel_;
  
  TH1F* h=getPlotHisto("hData");

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
    if((*s)->getDataType()=="Data"){
      //TH1F*hd=(*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      TH1F*hd=0;//
      if(nbins_>0) hd = (*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      else if(nbinsVariable_>0) hd = (*s)->getHistoNtpFile(plotvar_,nbinsVariable_,xbinsVariable_,sel);
      else { cout<<"binning not recognized "<<endl; return 0;}
      h->Add(hd);
      delete hd;
    }
 
  cout<<"TotalData : "<<h->Integral()<<endl;

  return h;
}



TH1F* TauElePlotter::getTotalMC(){
  TString sel="eventweight";
  if(Chcat_==1) sel += TString("*(abs(ditaucharge)==0)");
  if(Chcat_==2) sel += TString("*(abs(ditaucharge)==2)");
  if(Isocat_>0) sel += TString("*(categoryIso==")+(long)Isocat_+")";
  if(MTcat_==1)  sel += "*(transversemass<30)";
  if(MTcat_==3)  sel += "*(70<transversemass&&transversemass<150)";
  if(MTcat_==13)  sel += "*(60<transversemass&&transversemass<120)";
  if(extrasel_.CompareTo("1")!=0)sel += TString("*")+extrasel_;


  TH1F* h=getPlotHisto("hTotalMC");

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
    if((*s)->getDataType()=="MC"){// && TString((*s)->GetName()) != "ZToTauTau" && TString((*s)->GetName()) != "WJetsToLNu"){
      TH1F*hd=0;
      if(nbins_>0)hd=(*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      else if(nbinsVariable_>0) hd=(*s)->getHistoNtpFile(plotvar_,nbinsVariable_,xbinsVariable_,sel);
      else { cout<<"binning not recognized "<<endl; return 0;}
      h->Add(hd);  
      delete hd;
    }
 
  cout<<"Total MC : "<<h->Integral()<<endl;

  return h;
}



TH1F* TauElePlotter::getTotalEmbedded(){
  TString sel="eventweight";
  if(Chcat_==1) sel += TString("*(abs(ditaucharge)==0)");
  if(Chcat_==2) sel += TString("*(abs(ditaucharge)==2)");
  if(Isocat_>0) sel += TString("*(categoryIso==")+(long)Isocat_+")";
  if(MTcat_==1)  sel += "*(transversemass<30)";
  if(MTcat_==3)  sel += "*(70<transversemass&&transversemass<150)";
  if(MTcat_==13)  sel += "*(60<transversemass&&transversemass<120)";
  if(extrasel_.CompareTo("1")!=0)sel += TString("*")+extrasel_;


  TH1F* h=getPlotHisto("hEmbedded");

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s)
    if((*s)->getDataType()=="Embedded"){
      TH1F*hd=0;
      if(nbins_>0)hd=(*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      else if(nbinsVariable_>0) hd=(*s)->getHistoNtpFile(plotvar_,nbinsVariable_,xbinsVariable_,sel);
      else { cout<<"binning not recognized "<<endl; return 0;}
      h->Add(hd);  
      delete hd;
    }
 
  cout<<"TotalEmbedded : "<<h->Integral()<<endl;

  return h;
}


TH1F* TauElePlotter::getDiBoson(){

  TH1F* h=getPlotHisto("hVV");


  TH1F* hWW2L2Nu=getSample("WW2L2Nu");
  if(!hWW2L2Nu)return 0;
  h->Add(hWW2L2Nu);
  delete hWW2L2Nu;
  TH1F* hWZ3LNu=getSample("WZ3LNu");
  if(!hWZ3LNu)return 0;
  h->Add(hWZ3LNu);
  delete hWZ3LNu;
  TH1F* hWZ2L2Q=getSample("WZ2L2Q");
  if(!hWZ2L2Q)return 0;
  h->Add(hWZ2L2Q);
  delete hWZ2L2Q;
  TH1F* hZZ4L=getSample("ZZ4L");
  if(!hZZ4L)return 0;
  h->Add(hZZ4L);
  delete hZZ4L;
  TH1F* hZZ2L2Nu=getSample("ZZ2L2Nu");
  if(!hZZ2L2Nu)return 0;
  h->Add(hZZ2L2Nu);
  delete hZZ2L2Nu;
  TH1F* hZZ2L2Q=getSample("ZZ2L2Q");
  if(!hZZ2L2Q)return 0;
  h->Add(hZZ2L2Q);
  delete hZZ2L2Q;

  TH1F* hTopTW=getSample("TopTW");
  if(!hTopTW)return 0;
  h->Add(hTopTW);
  delete hTopTW;

  TH1F* hTopBTW=getSample("TopBTW");
  if(!hTopBTW)return 0;
  h->Add(hTopBTW);
  delete hTopBTW;
 
  cout<<"DiBoson : "<<h->Integral()<<endl;

  return h;
}


TH1F* TauElePlotter::getZToTauTau(){  
  TH1F*h=0;
  if(ZTTType_==1)h=getSample("ZToTauTau");
  if(ZTTType_==2)h=getTotalEmbedded(); 
  return h;
}



//TTJets
TH1F* TauElePlotter::getTTJetsInc(){
  TH1F*h=getSample("TTJets");
  return h;
}

//ZLJet
TH1F* TauElePlotter::getZToLJetInc(){
  TH1F*h=getSample("ZToLJet");
  return h;
}


//ZMuMu
TH1F* TauElePlotter::getZToEEInc(){
  TH1F*h=getSample("ZToEE");
  return h;
}

TH1F* TauElePlotter::getTotalMCSM(){
  TH1F* h=getPlotHisto("hTotalsMCSM");

  TH1F*hZToTauTau=getZToTauTau();
  if(!hZToTauTau)return 0;
  h->Add(hZToTauTau);
  delete hZToTauTau;
  TH1F*hWJets=getWJetsInc();
  if(!hWJets)return 0;
  h->Add(hWJets);
  delete hWJets;
  TH1F*hDiBoson=getDiBoson();
  if(!hDiBoson)return 0;
  h->Add(hDiBoson);
  delete hDiBoson;
  TH1F*hTTJets=getTTJetsInc();
  if(!hTTJets)return 0;
  h->Add(hTTJets);
  delete hTTJets;
  TH1F*hZLJet=getZToLJetInc();
  if(!hZLJet)return 0;
  h->Add(hZLJet);
  delete hZLJet;
  TH1F*hZToEE=getZToEEInc();
  if(!hZToEE)return 0;
  h->Add(hZToEE);
  delete hZToEE;


  cout<<" TotalMCSM : "<<h->Integral()<<endl;
  return h;
}



//////////W+jets estimations////////////////////////////
TH1F* TauElePlotter::getWJetsInc(){
  cout<<" Calling getWJetsInc "<<endl;
  TString sname="WJetsToLNu";

  //shape of W+jets
  TH1F*hShape=getSample(sname);
  hShape->SetName("getWJetsInc");

  //determine normalization
  Int_t tmpCategoryMT=MTcat_;
  MTcat_=3;
  if(MSSMFlag_)  MTcat_=103;//use pZeta
  cout<<"  **** Normalzing WJets from MTcat=="<<MTcat_<<endl;
  TH1F* HW=getSample(sname);
  TH1F* HData=getTotalData();
  TH1F* HMC=getZToTauTau();
  TH1F* HTT=getTTJetsInc();   HMC->Add(HTT); delete HTT;
  TH1F* HVV=getDiBoson();     HMC->Add(HVV); delete HVV;
  TH1F* HZL=getZToEEInc();    HMC->Add(HZL); delete HZL;
  TH1F* HZJ=getZToLJetInc();  HMC->Add(HZJ); delete HZJ;

  MTcat_=tmpCategoryMT;
  if(HW->Integral()>0.) 
    hShape->Scale((HData->Integral()-HMC->Integral())/HW->Integral());
  else {
    cout<<"WARNING HW->Integral is 0"<<endl;
    hShape->Scale(0.);
  }
  delete HData;
  delete HMC;
  delete HW;


  cout<<"getWJetsInc : "<<hShape->Integral()<<endl;
  return hShape;
}


TH1F* TauElePlotter::getWNJetSum(){
  TH1F*hShape=getSample("W1JetsToLNu");
  hShape->SetName("getWNJetSum");
  TH1F* HW2Shape=getSample("W2JetsToLNu"); hShape->Add(HW2Shape); delete HW2Shape;
  TH1F* HW3Shape=getSample("W3JetsToLNu"); hShape->Add(HW3Shape); delete HW3Shape;
  TH1F* HW4Shape=getSample("W4JetsToLNu"); hShape->Add(HW4Shape); delete HW4Shape;
  //TH1F* HWIncShape=getSample("WJetsToLNu"); hShape->Add(HWIncShape); delete HWIncShape;
  return hShape;
}



TH1F* TauElePlotter::getWJetsNJet(){
  TH1F*hShape=getSample("W1JetsToLNu");
  hShape->SetName("getWJetsNJet");
  TH1F* HW2Shape=getSample("W2JetsToLNu"); hShape->Add(HW2Shape); delete HW2Shape;
  TH1F* HW3Shape=getSample("W3JetsToLNu"); hShape->Add(HW3Shape); delete HW3Shape;
  TH1F* HW4Shape=getSample("W4JetsToLNu"); hShape->Add(HW4Shape); delete HW4Shape;

  //determine normalization
  Int_t tmpCategoryMT=MTcat_;//switch to high mT
  MTcat_=3;
  if(MSSMFlag_)  MTcat_=103;//use pZeta
  //cout<<"  **** Normalzing WJets from MTcat=="<<MTcat_<<endl;
  TH1F* HW=getSample("W1JetsToLNu");
  TH1F* HW2=getSample("W2JetsToLNu"); HW->Add(HW2); delete HW2;
  TH1F* HW3=getSample("W3JetsToLNu"); HW->Add(HW3); delete HW3;
  TH1F* HW4=getSample("W4JetsToLNu"); HW->Add(HW4); delete HW4;
  TH1F* HData=getTotalData();
  TH1F* HMC=getZToTauTau();
  TH1F* HTT=getTTJetsInc();  HMC->Add(HTT); delete HTT;
  TH1F* HVV=getDiBoson();     HMC->Add(HVV); delete HVV;
  TH1F* HZL=getZToMuMuInc(); HMC->Add(HZL); delete HZL;
  TH1F* HZJ=getZToLJetInc(); HMC->Add(HZJ); delete HZJ;

  //return to Category
  MTcat_=tmpCategoryMT;

  if(HW->Integral()>1.){
    hShape->Scale((HData->Integral()-HMC->Integral())/HW->Integral());
  }else {
    cout<<"WARNING HW->Integral is 0"<<endl;
    hShape->Scale(0.);
  }
  delete HData;
  delete HMC;
  delete HW;

  cout<<" getWJetsInc integral : "<<hShape->Integral()<<endl;
  return hShape;
}




TH1F* TauElePlotter::getWJetsNJetVBFHCP(){

  TString shapesel="(njet>=2&&njetingap==0&&diJetMass>200&&abs(diJetDeltaEta)>2.0)";

  TString tmpextrasel=extrasel_;
  Int_t tmpCategoryMT=MTcat_;

  ///get the mass template with relaxed selection but at low mT

  extrasel_=shapesel;
  TH1F*hShape=getWNJetSum();
  hShape->SetName("getWJetsNJetShape");
  extrasel_=tmpextrasel;

  ///get Data - MC at high mT without relaxed selection
  MTcat_=13;
  TH1F* HData=getTotalData(); HData->SetName("HData");
  cout<<" Data high mT : "<<HData->Integral()<<endl;
  TH1F* HMC=getZToTauTau();  HMC->SetName("HMC");  cout<<" ZTT high mT : "<<HMC->Integral()<<endl;
  TH1F* HTT=getTTJetsInc();  HMC->Add(HTT); cout<<" TT high mT : "<<HTT->Integral()<<endl;  delete HTT;
  TH1F* HVV=getDiBoson();    HMC->Add(HVV); cout<<" VV high mT : "<<HVV->Integral()<<endl;  delete HVV;
  TH1F* HZL=getZToEEInc(); HMC->Add(HZL); cout<<" ZL high mT : "<<HZL->Integral()<<endl;  delete HZL;
  TH1F* HZJ=getZToLJetInc(); HMC->Add(HZJ); cout<<" ZJ high mT : "<<HZJ->Integral()<<endl;   delete HZJ;
  cout<<" Data - MC high mT : "<<HData->Integral()-HMC->Integral()<<endl;

  ///switch the plotVariable to get a good integral
  TString tmpplotvar=plotvar_;
  plotvar_="ditaumass";
  Int_t tmpnbins=nbins_;
  nbins_=10;
  Float_t tmpxmin=xmin_;
  xmin_=0;
  Float_t tmpxmax=xmax_;
  xmax_=1000;

  ///relax selection to get integral of W Shape at high mT
  extrasel_=shapesel;
  TH1F* HWH=getWNJetSum();
  HWH->SetName("HWH");
  ///get the integral of W at low mT 
  MTcat_=tmpCategoryMT;
  TH1F*HWL=getWNJetSum();
  HWL->SetName("HWL");
  extrasel_=tmpextrasel;
  
  plotvar_=tmpplotvar;
  nbins_=tmpnbins;
  xmin_=tmpxmin;
  xmax_=tmpxmax;
  
  if(HWH->Integral()>0.){
    cout<<" W high mT : "<<HWH->Integral()<<endl;
    cout<<" W low mT : "<<HWL->Integral()<<endl;
    Float_t NWL=HWL->Integral();
    Float_t NWH=HWH->Integral();
    Float_t NWLerr=0.;
    Float_t NWHerr=0.;
    for(Int_t i=1;i<=HWL->GetNbinsX();i++){
      NWLerr+=HWL->GetBinError(i)*HWL->GetBinError(i);
      NWHerr+=HWH->GetBinError(i)*HWH->GetBinError(i);
    }
    NWLerr=sqrt(NWLerr);
    NWHerr=sqrt(NWHerr);
    Float_t ratio=NWL/NWH;
    Float_t ratioerr=ratio*sqrt((NWLerr*NWLerr)/(NWL*NWL)+(NWHerr*NWHerr)/(NWH*NWH));

    cout<<" extrapolation factor : "<<ratio<<" +- "<<ratioerr<<endl;
    hShape->Scale(((HData->Integral()-HMC->Integral())*ratio)/hShape->Integral());
  }else {
    cout<<"WARNING HW->Integral is 0"<<endl;
    hShape->Scale(0.);
  }
  delete HData;
  delete HMC;
  delete HWH;
  delete HWL;

  return hShape;
}



TH1F* TauElePlotter::getWJetsInc2012(){
  TString sname;   
  if(WJetsType_==3) sname="W3JetsToLNu";
  else if(WJetsType_==2) sname="W2JetsToLNu";
  else sname="WJetsToLNu";

  //shape of W+jets
  TH1F*hShape=getSample(sname);
  hShape->SetName("getWJetsInc");

  //determine normalization
  Int_t tmpCategoryMT=MTcat_;
  MTcat_=13;
  if(MSSMFlag_)  MTcat_=103;//use pZeta
  cout<<"  **** Normalzing WJets from MTcat=="<<MTcat_<<endl;
  TH1F* HW=getSample(sname);
  TH1F* HData=getTotalData();
  TH1F* HMC=getZToTauTau();
  TH1F* HTT=getTTJetsInc();
  HMC->Add(HTT); delete HTT;
  TH1F* HZJ=getZToLJetInc();
  HMC->Add(HZJ); delete HZJ;
  TH1F* HZL=getZToEEInc();
  HMC->Add(HZL); delete HZL;
  TH1F* hQCD=getQCDIncFit();////Need to subtract QCD because it extends at high mT
  HMC->Add(hQCD); delete hQCD;
  MTcat_=tmpCategoryMT;
  if(HW->Integral()>0.) 
    hShape->Scale((HData->Integral()-HMC->Integral())/HW->Integral());
  else {
    cout<<"WARNING HW->Integral is 0"<<endl;
    hShape->Scale(0.);
  }
  delete HData;
  delete HMC;
  delete HW;


  cout<<"getWJetsInc : "<<hShape->Integral()<<endl;
  return hShape;
}


TH1F* TauElePlotter::getWJetsIncShape(){
  cout<<" calling method getWJetsIncShape"<<endl;

  TString tmpextrasel=extrasel_;
  Int_t tmpMTcat=MTcat_;
  Int_t tmpIsocat=Isocat_;

  //get shape from relaxed iso 
  Isocat_=-1;//relax isolation
  extrasel_ = extrasel_ + "*(muiso<0.15&&tauisomva>0.5)";
  cout<<" using relaxed iso selection :"<<extrasel_<<endl;
  TH1F* hShape=getSample("WJetsToLNu");
  hShape->SetName("hShape");

  //go to high mT still with relaxed 
  MTcat_=13;
  if(MSSMFlag_)MTcat_=103;
  TH1F* hShapeHighMT=getSample("WJetsToLNu");
  hShapeHighMT->SetName("hShapeHighMT");

  //normalize to at high mT
  extrasel_=tmpextrasel;
  Isocat_=tmpIsocat;
  TH1F* hDataHighMT=getTotalData();
  TH1F* hZToTauTau=getZToTauTau();
  hDataHighMT->Add(hZToTauTau,-1); delete hZToTauTau;
  TH1F* hTTJets=getSample("TTJets");
  hDataHighMT->Add(hTTJets,-1); delete hTTJets;
  TH1F* hZToLJet=getSample("ZToLJet");
  hDataHighMT->Add(hZToLJet,-1); delete hZToLJet;
  TH1F* hZToEE=getSample("ZToEE");
  hDataHighMT->Add(hZToEE,-1); delete hZToEE;
  MTcat_=tmpMTcat;

  //
  hShape->Scale(hDataHighMT->Integral()/hShapeHighMT->Integral());
  delete hDataHighMT;
  delete hShapeHighMT;
  
  return hShape;
}




TH1F* TauElePlotter::getWJetsIncShape2012(){
  cout<<" calling method getWJetsIncShape"<<endl;

  TString sname;   
  if(WJetsType_==3) sname="W3JetsToLNu";
  else if(WJetsType_==2) sname="W2JetsToLNu";
  else sname="WJetsToLNu";


  TString tmpextrasel=extrasel_;
  Int_t tmpMTcat=MTcat_;
  Int_t tmpIsocat=Isocat_;

  //this factor is to use the 2011 Sample in 2012 analysis
  //extrasel_ += "*(mupt>24)*((nvtx==0)*0+(nvtx==1)*0.0245307+(nvtx==2)*0.048848+(nvtx==3)*0.0638493+(nvtx==4)*0.116917+(nvtx==5)*0.15697+(nvtx==6)*0.268479+(nvtx==7)*0.445571+(nvtx==8)*0.645714+(nvtx==9)*0.998239+(nvtx==10)*1.37402+(nvtx==11)*1.91361+(nvtx==12)*2.58661+(nvtx==13)*3.4313+(nvtx==14)*5.05569+(nvtx==15)*7.44155+(nvtx==16)*9.92943+(nvtx==17)*15.881+(nvtx==18)*24.6622+(nvtx==19)*38.3726+(nvtx==20)*57.9205+(nvtx==21)*99.3125+(nvtx==22)*150.007+(nvtx==23)*248.378+(nvtx==24)*357.212+(nvtx==25)*556.722+(nvtx==26)*688.842+(nvtx==27)*1295.89+(nvtx==28)*1578.77+(nvtx==29)*1500.43)";

  //get shape from relaxed iso 
  Isocat_=-1;//relax isolation
  extrasel_ = extrasel_ + "*(muiso<0.15&&tauisomva>0.5)";
  cout<<" using relaxed iso selection :"<<extrasel_<<endl;
  TH1F* hShape=getSample(sname);
  hShape->SetName("hShape");

  //go to high mT still with relaxed 
  MTcat_=13;
  if(MSSMFlag_)MTcat_=103;
  TH1F* hShapeHighMT=getSample(sname);
  hShapeHighMT->SetName("hShapeHighMT");

  //normalize to at high mT
  extrasel_=tmpextrasel;
  Isocat_=tmpIsocat;
  TH1F* hDataHighMT=getTotalData();
  TH1F* hZToTauTau=getZToTauTau();
  hDataHighMT->Add(hZToTauTau,-1); delete hZToTauTau;
  TH1F* hTTJets=getSample("TTJets");
  hDataHighMT->Add(hTTJets,-1); delete hTTJets;
  TH1F* hZToLJet=getSample("ZToLJet");
  hDataHighMT->Add(hZToLJet,-1); delete hZToLJet;
  TH1F* hZToEE=getSample("ZToEE");
  hDataHighMT->Add(hZToEE,-1); delete hZToEE;
  TH1F* hQCD=getQCDIncFit();////Need to subtract QCD because it extends at high mT
  hDataHighMT->Add(hQCD,-1); delete hQCD;
  MTcat_=tmpMTcat;

  //
  hShape->Scale(hDataHighMT->Integral()/hShapeHighMT->Integral());
  delete hDataHighMT;
  delete hShapeHighMT;
  
  return hShape;
}


TH1F* TauElePlotter::getW3JetsVBF(){
  cout<<" calling getW3JetsVBF"<<endl;

  //
  TString TmpExtrasel=extrasel_;
  Int_t tmpMTcat=MTcat_;
  Int_t tmpIsocat=Isocat_;
  
  //relax selections
  Isocat_=-1;
  extrasel_="(njet>=2&&muiso<0.1&&tauisomva>-0.75)"; 
  cout<<"Determining WJets template with relaxed selection: "<<extrasel_<<endl;
  TH1F* hW3JetsShape=getSample("W3JetsToLNu");
  hW3JetsShape->SetName("hW3JetsShape");

  //go to high mT with same selections as shape
  MTcat_=13;
  TH1F* hW3JetsShapeHighMT=getSample("W3JetsToLNu");
  hW3JetsShapeHighMT->SetName("hW3JetsShapeHighMT");

  //return to VBF catetory But stay at high mT
  Isocat_=tmpIsocat;
  extrasel_=TmpExtrasel;  

  //determine normalization factor
  //Get Data and TTJets at high mT in VBF
  TH1F* hDataHighMT=getTotalData();
  hDataHighMT->SetName("hDataHighMT");
  TH1F* hMCHighMT=getSample("TTJets");
  hMCHighMT->SetName("hMC");
  TH1F* hZTTHighMT=getZToTauTau();
  hMCHighMT->Add(hZTTHighMT); delete hZTTHighMT;
  TH1F* hZJHighMT=getSample("ZToLJet");
  hMCHighMT->Add(hZJHighMT); delete hZJHighMT;
  TH1F* hZEEHighMT=getSample("ZToEE");
  hMCHighMT->Add(hZEEHighMT); delete hZEEHighMT;


  //Return signal mT region
  MTcat_=tmpMTcat;

  //normalize the Template
  hW3JetsShape->Scale((hDataHighMT->Integral()-hMCHighMT->Integral())/hW3JetsShapeHighMT->Integral());
  
  delete hW3JetsShapeHighMT;
  delete hDataHighMT;
  delete hMCHighMT;

  return hW3JetsShape;
}


TH1F* TauElePlotter::getW2JetsBJet(){
  cout<<" calling getW2JetsBJet"<<endl;

// Keti:
// Wjets normalization with p_zeta
// *check normalization in p_zeta < -40
// * apply the correction in signal region p_zeta > -20
// Wjets shape
// * using W2jet sample without bjet requirement (if needed) and without OS charge requirement.


  TString TmpExtrasel=extrasel_;
  Int_t tmpIsocat=Isocat_;
  Isocat_=-1;
  extrasel_=extrasel_+"*(muiso<0.1&&tauisomva>-0.75)";
  TH1F* hWJetsShape=getSample("W2JetsToLNu");
  hWJetsShape->SetName("hWJetsShape");
  cout<<"hWJetsShape :"<<hWJetsShape->Integral()<<endl;

  Int_t tmpMTcat=MTcat_;
  MTcat_=103;  //need to know integral of template at high mT for normalization

  TH1F* hWJetsShapeHighMT=getSample("W2JetsToLNu");
  hWJetsShapeHighMT->SetName("hWJetsShapeHighMT");
  Isocat_=tmpIsocat;
  extrasel_=TmpExtrasel;  //return to category at but stay at high mT

  //determine normalization factor
  TH1F* hDataHighMT=getTotalData();
  hDataHighMT->SetName("hDataHighMT");
  cout<<"hDataHighMT :"<<hDataHighMT->Integral()<<endl;
  TH1F* hTTJetsHighMT=getSample("TTJets");
  hTTJetsHighMT->SetName("hTTJetsHighMT");
  cout<<"hTTJetsHighMT :"<<hTTJetsHighMT->Integral()<<endl;
  TH1F* hZTTHighMT=getZToTauTau();
  hZTTHighMT->SetName("hZTTHighMT");
  cout<<"hZTTHighMT :"<<hZTTHighMT->Integral()<<endl;
  TH1F* hZJHighMT=getSample("ZToLJet");
  hZJHighMT->SetName("hZJHighMT");
  cout<<"hZJHighMT :"<<hZJHighMT->Integral()<<endl;
  MTcat_=tmpMTcat;//Return signal  region

  //normalize the Template
  Float_t WJetsIntegralFromhighMTData=(hDataHighMT->Integral()-hTTJetsHighMT->Integral()-hZTTHighMT->Integral()-hZJHighMT->Integral());
  float scale=WJetsIntegralFromhighMTData/hWJetsShapeHighMT->Integral();
  cout<<" Scaling WJets by factor "<<scale<<endl;
  hWJetsShape->Scale(scale);
  
  delete hWJetsShapeHighMT;
  delete hDataHighMT;
  delete hTTJetsHighMT;
  delete hZTTHighMT;
  delete hZJHighMT;

  cout<<"----> getWJets yield: "<<hWJetsShape->Integral()<<endl;
 

  return hWJetsShape;
}




////////QCD estimations/////////////////////////////////

TH1F* TauElePlotter::getQCDInc(){
  cout<<"Calling method getQCDInc"<<endl;

  TH1F* h=getPlotHisto("hQCDInc");
  
  int ChcatTmp=Chcat_;
  Chcat_=2;

  TH1F* hDataSS=getTotalData();
  h->Add(hDataSS);
  delete hDataSS;

  //subtract MC
  TH1F*hZToTauTau=getZToTauTau();  h->Add(hZToTauTau,-1); delete hZToTauTau;
  TH1F*hWJets=getWJetsInc();       h->Add(hWJets,-1);     delete hWJets;
  TH1F*hDiBoson=getDiBoson();      h->Add(hDiBoson,-1);   delete hDiBoson;
  TH1F*hTTJets=getTTJetsInc();     h->Add(hTTJets,-1);    delete hTTJets;
  TH1F*hZLJet=getZToLJetInc();     h->Add(hZLJet,-1);     delete hZLJet;
  TH1F*hZToEE=getZToEEInc();       h->Add(hZToEE,-1);     delete hZToEE;

  Chcat_=ChcatTmp;

  cout<<"Scaling QCDInc by OS/SS factor "<<QCDOStoSSRatio_<<endl;
  h->Scale(QCDOStoSSRatio_);

  return h;
}


TH1F* TauElePlotter::getQCDIncLooseShape(){
  cout<<"Calling method getQCDIncHighPt"<<endl;

  //integral from SS after subtracting MC
  TH1F* hNorm=getQCDInc();

  //Shape from sample with loose isolation
  TH1F* h=getPlotHisto("hQCDIncHigPt");
  
  int ChcatTmp=Chcat_;
  Chcat_=2;
  int IsocatTmp=Isocat_;
  Isocat_=0;
  TString extraselTmp=extrasel_;
  extrasel_+="*(muiso<0.5&&tauisomva>-0.5)";
  
  TH1F* hDataSS=getTotalData();
  h->Add(hDataSS);
  delete hDataSS;
  TH1F*hMC=getTotalMCSM();
  h->Add(hMC,-1);
  delete hMC;

  //remove negative bins
  for(Int_t b=1;b<=h->GetNbinsX();b++)
    if(h->GetBinContent(b)<0.)h->SetBinContent(b,0);

  Chcat_=ChcatTmp;
  Isocat_=IsocatTmp;
  extrasel_=extraselTmp;

  if(h->Integral()>0)
    h->Scale(TMath::Max(hNorm->Integral(),1.)/h->Integral());
  
  return h;
}


TH1F* TauElePlotter::getQCDIncWJetsShape(){
  cout<<"Calling method getQCDIncWJetsShape"<<endl;

  //yield
  TH1F* h=getPlotHisto("hQCDInc");

  int ChcatTmp=Chcat_;
  Chcat_=2;


  TH1F* hDataSS=getTotalData();
  h->Add(hDataSS); delete hDataSS;
  TH1F*hZToTauTau=getZToTauTau();
  h->Add(hZToTauTau,-1);  delete hZToTauTau;
  TH1F*hWJets=getWJetsIncShape();
  h->Add(hWJets,-1);  delete hWJets;
  TH1F*hDiBoson=getDiBoson();
  h->Add(hDiBoson,-1);  delete hDiBoson;
  TH1F*hTTJets=getTTJetsInc();
  h->Add(hTTJets,-1);  delete hTTJets;
  TH1F*hZLJet=getZToLJetInc();
  h->Add(hZLJet,-1);  delete hZLJet;
  TH1F*hZToEE=getZToEEInc();
  h->Add(hZToEE,-1);  delete hZToEE;  

  cout<<"Scaling QCDInc by OS/SS factor "<<QCDOStoSSRatio_<<endl;
  h->Scale(QCDOStoSSRatio_);

  //Shape
  char isocuttxtshape[100];
  sprintf(isocuttxtshape,"(0.2<muiso&&muiso<%.3f&&tauisomva>%.3f)",0.5,-0.75);//for shape
  cout<<"QCD Shape with loose iso cut: "<<isocuttxtshape<<endl;
  Int_t tmpIsocat=Isocat_;
  TString tmpExtrasel=extrasel_;
  Isocat_=-1;
  extrasel_=extrasel_+"*"+isocuttxtshape;
  TH1F* hShape=getTotalData(); 
  TH1F*hZToTauTauShape=getZToTauTau();
  hShape->Add(hZToTauTauShape,-1);  delete hZToTauTauShape;
  TH1F*hWJetsShape=getWJetsIncShape();
  hShape->Add(hWJetsShape,-1);  delete hWJetsShape;
  TH1F*hDiBosonShape=getDiBoson();
  hShape->Add(hDiBosonShape,-1);  delete hDiBosonShape;
  TH1F*hTTJetsShape=getTTJetsInc();
  hShape->Add(hTTJetsShape,-1);  delete hTTJetsShape;
  TH1F*hZLJetShape=getZToLJetInc();
  hShape->Add(hZLJetShape,-1);  delete hZLJetShape;
  TH1F*hZToEEShape=getZToEEInc();
  hShape->Add(hZToEEShape,-1);  delete hZToEEShape;  
  hShape->Scale(h->Integral()/hShape->Integral()); delete h;
  Isocat_=tmpIsocat;
  extrasel_=tmpExtrasel;


  Chcat_=ChcatTmp;

  return hShape;
}


TH1F* TauElePlotter::getQCDIncFit(){
  cout<<"Calling method getQCDIncFit"<<endl;
  
  /////////////////fit to the transversemass
  //-relax mT cut to be able to make fit
  //-subtract ZTT+ZEE+ZJ+TT backgrounds
  //-get WJets template
  //-get QCD template
  //-fit the remaing SS distribution with these templates
  //get QCD in varible distribution with full selections
  //get QCD in variable distribution withou mT cut
  //rescale first QCD 

  
  int ChcatTmp=Chcat_;
  Chcat_=2;

  Int_t tmpIsocat=Isocat_;
  Int_t tmpMTcat=MTcat_;
  TString tmpExtrasel=extrasel_;
  TString tmpPlotVar=plotvar_;
  float tmpXmin=xmin_;
  float tmpXmax=xmax_;
  Int_t tmpnbins=nbins_;

  /// get mT distribution in SS Data
  MTcat_=0;
  plotvar_="transversemass";
  xmin_=0;
  xmax_=200;
  nbins_=20;

  TH1F* hQDCPlusW=getPlotHisto("hQDCPlusW");
  TH1F* hDataSS=getTotalData();
  hQDCPlusW->Add(hDataSS);       delete hDataSS;
  TH1F*hZToTauTau=getZToTauTau();
  hQDCPlusW->Add(hZToTauTau,-1); delete hZToTauTau;
  TH1F*hDiBoson=getDiBoson();
  hQDCPlusW->Add(hDiBoson,-1);   delete hDiBoson;
  TH1F*hTTJets=getTTJetsInc();
  hQDCPlusW->Add(hTTJets,-1);    delete hTTJets;
  TH1F*hZLJet=getZToLJetInc();
  hQDCPlusW->Add(hZLJet,-1);     delete hZLJet;
  TH1F*hZToEE=getZToEEInc();
  hQDCPlusW->Add(hZToEE,-1);     delete hZToEE;


  Isocat_=-1;
  
  //Get QCD template
  char isocuttxtshapeQCD[100];
  sprintf(isocuttxtshapeQCD,"(0.1<muiso&&muiso<0.2&&tauisomva>0.0)");//for shape
  cout<<"QCD template iso cut: "<<isocuttxtshapeQCD<<endl;
  extrasel_=extrasel_+"*"+isocuttxtshapeQCD;
  TH1F*hQCDTemplate=getTotalData();
  hQCDTemplate->SetName("hQCDTemplate");
  TH1F*hZToTauTauQCDTemplate=getZToTauTau();
  hQCDTemplate->Add(hZToTauTauQCDTemplate,-1); delete hZToTauTauQCDTemplate;
  TH1F*hDiBosonQCDTemplate=getDiBoson();
  hQCDTemplate->Add(hDiBosonQCDTemplate,-1);   delete hDiBosonQCDTemplate;
  TH1F*hTTJetsQCDTemplate=getTTJetsInc();
  hQCDTemplate->Add(hTTJetsQCDTemplate,-1);    delete hTTJetsQCDTemplate;
  TH1F*hZLJetQCDTemplate=getZToLJetInc();
  hQCDTemplate->Add(hZLJetQCDTemplate,-1);     delete hZLJetQCDTemplate;
  TH1F*hZToEEQCDTemplate=getZToEEInc();
  hQCDTemplate->Add(hZToEEQCDTemplate,-1);     delete hZToEEQCDTemplate;
  if(hQCDTemplate->Integral()>0.){
    hQCDTemplate->Scale(1./hQCDTemplate->Integral());
  }else return 0;
  //There is some W contribution with this isolation cut but dont know how to normalize it so just ignored
  extrasel_=tmpExtrasel;


  //Get WJets template
  extrasel_=extrasel_+"*(muiso<0.15&&tauisomva>0.5)";
  TH1F*hWTemplate=getSample("WJetsToLNu");
  hWTemplate->Scale(1./hWTemplate->Integral());
  extrasel_=tmpExtrasel;


  Isocat_=tmpIsocat;


  ///
  RooRealVar x("x","x",xmin_,xmax_);
  //  RooDataHist QCDDataHist("QCDDataHist","",RooArgList(x),hQCDTemplate);
//   RooDataHist WDataHist("WDataHist","",RooArgList(x),hWTemplate);
//   RooHistPdf QCDPdf("QCDPdf","",RooArgSet(x),QCDDataHist);
//   RooHistPdf WPdf("WPdf","",RooArgSet(x),WDataHist);
  RooRealVar coef("coef","coef",0,1);
//  RooAddPdf QCDPlusWPdf("QCDPlusWPdf","",WPdf,QCDPdf,coef);
//   RooDataHist QCDPlusWData("QCDPlusWData","",RooArgList(x),hQDCPlusW);
//   RooChi2Var chi2("chi2","chi2",QCDPlusWPdf,QCDPlusWData);
//   RooMinuit min(chi2);
//   min.migrad();

  //normalize template to fitted yield
  hQCDTemplate->Scale(coef.getVal()*hQDCPlusW->Integral());

  //show the fit
  TCanvas cTemp;
  hWTemplate->Scale((1-coef.getVal())*hQDCPlusW->Integral());
  hWTemplate->Add(hQCDTemplate);
  hWTemplate->SetFillColor(kRed+2);
  hWTemplate->Draw("hist");
  hQCDTemplate->SetFillColor(kMagenta-10);
  hQCDTemplate->Draw("histsame");
  hQDCPlusW->Draw("histpesame");
  cTemp.Print("TauElePlotter_getQCDIncFit.ps");
  delete hQDCPlusW;
  delete hWTemplate;



  //return to normal
  Isocat_=tmpIsocat;
  extrasel_=tmpExtrasel;
  MTcat_=tmpMTcat;
  plotvar_=tmpPlotVar;
  xmin_=tmpXmin;
  xmax_=tmpXmax;
  nbins_=tmpnbins;

  ///now get the distribution for plot 
  Isocat_=-1;
  extrasel_=extrasel_+"*"+isocuttxtshapeQCD;
  TH1F*hQCDIncFit=getTotalData();
  hQCDIncFit->SetName("hQCDIncFit");
  TH1F*hZToTauTauPlotVar=getZToTauTau();
  hQCDIncFit->Add(hZToTauTauPlotVar,-1); delete hZToTauTauPlotVar;
  TH1F*hDiBosonPlotVar=getDiBoson();
  hQCDIncFit->Add(hDiBosonPlotVar,-1);   delete hDiBosonPlotVar;
  TH1F*hTTJetsPlotVar=getTTJetsInc();
  hQCDIncFit->Add(hTTJetsPlotVar,-1);    delete hTTJetsPlotVar;
  TH1F*hZLJetPlotVar=getZToLJetInc();
  hQCDIncFit->Add(hZLJetPlotVar,-1);     delete hZLJetPlotVar;
  TH1F*hZToEEPlotVar=getZToEEInc();
  hQCDIncFit->Add(hZToEEPlotVar,-1);     delete hZToEEPlotVar;
  //normalize according to QCD yield from fit above
  MTcat_=0;
  TH1F*hQCDforNorm=getTotalData();
  hQCDIncFit->Scale(hQCDTemplate->Integral()/hQCDforNorm->Integral());
  delete hQCDTemplate;
  delete hQCDforNorm;
  Isocat_=tmpIsocat;
  extrasel_=tmpExtrasel;
  MTcat_=tmpMTcat;

  cout<<"Scaling QCDInc by OS/SS factor "<<QCDOStoSSRatio_<<endl;
  hQCDIncFit->Scale(QCDOStoSSRatio_);


  Chcat_=ChcatTmp;
  return hQCDIncFit;
}


  
TH1F* TauElePlotter::getQCDKeti(){
  cout<<" Calling getQCDKeti only for b-jet category "<<endl;


// QCD normalization (Keti)
// * in SS data events in p_zeta>-20 remove contribution from SM processes, multiply by 1.11
// ---> When I was doing before, I was using normalization for SS Wjets obtained from inclusive selection, i.e. not b-jet requirement.
// QCD shape
// * in SS data events with inverted isolation on muon (0.15 < iso < 0.4). The rest of the selection is the same as category.


  
  int ChcatTmp=Chcat_;
  Chcat_=2;

  //determine yield
  cout<<"QCD yield from SSx1.11 method"<<endl;

  TH1F* hQCDInc=getPlotHisto("hQCDKeti");

  TH1F* hDataSS=getTotalData();
  hQCDInc->Add(hDataSS);
  delete hDataSS;

  TH1F*hZToTauTauSS=getZToTauTau();
  if(!hZToTauTauSS)return 0;
  hQCDInc->Add(hZToTauTauSS,-1);
  delete hZToTauTauSS;

  cout<<"Using getW2JetsBJetSS, should only be used for b-jet category"<<endl;
  TH1F*hWJetsSS=getW2JetsBJet();
  if(!hWJetsSS) return 0;
  hQCDInc->Add(hWJetsSS,-1);
  delete hWJetsSS;

  TH1F*hTTJetsSS=getTTJetsInc();
  if(!hTTJetsSS)return 0;
  hQCDInc->Add(hTTJetsSS,-1);
  delete hTTJetsSS;

  TH1F*hZToLJetSS=getZToLJetInc();
  if(!hZToLJetSS)return 0;
  hQCDInc->Add(hZToLJetSS,-1);
  delete hZToLJetSS;

  TH1F*hZToEESS=getZToEEInc();
  if(!hZToEESS)return 0;
  hQCDInc->Add(hZToEESS,-1);
  delete hZToEESS;

  TH1F*hDiBosonSS=getDiBoson();
  if(!hDiBosonSS)return 0;
  hQCDInc->Add(hDiBosonSS,-1);
  delete hDiBosonSS;

  hQCDInc->Scale(QCDOStoSSRatio_);



  //determine shape
  char isocuttxtshape[100];
  sprintf(isocuttxtshape,"(%.2f<muiso&&muiso<%.2f&&tauisomva>%.2f)",0.2,0.5,-0.75);//for shape
  cout<<"Calculating QCD Shape with Keti Method and loose iso cut: "<<isocuttxtshape<<endl;
  
  Int_t TmpIsocat=Isocat_;
  TString TmpExtrasel=extrasel_;  
  Isocat_=-1;
  extrasel_=extrasel_+"*"+isocuttxtshape;
  TH1F* hQCDShape = getTotalData(); 

  TH1F* hZToTauTau = getZToTauTau();
  hQCDShape->Add(hZToTauTau,-1);
  delete hZToTauTau;

  TH1F*hTTJets=getTTJetsInc();
  hQCDShape->Add(hTTJets,-1);
  delete hTTJets;

  TH1F*hZLJet=getZToLJetInc();
  hQCDShape->Add(hZLJet,-1);
  delete hZLJet;

  //return selections
  Isocat_=TmpIsocat;
  extrasel_=TmpExtrasel;


  if(hQCDShape->Integral()>0)
    hQCDShape->Scale(hQCDInc->Integral()/hQCDShape->Integral());
  else {
    cout<<"hQCDShape integral is 0 cannot normalize shape "<<endl;
    hQCDShape->Scale(0.);
  }
  delete hQCDInc;


  Chcat_=ChcatTmp;
  return hQCDShape;
}



TH1F* TauElePlotter::getQCDMike(){

  char isocuttxt[100];
  sprintf(isocuttxt,"(0.2<muiso&&muiso<%.3f&&tauisomva>%.3f)",0.5,0.0);//for normalization
  cout<<"Calculating QCD Yield with Mike Method and loose iso cut: "<<isocuttxt<<endl;
  
  int ChcatTmp=Chcat_;
  Chcat_=2;

  Int_t TmpIsocat=Isocat_;
  TString TmpExtrasel=extrasel_;  
   
  //SS incl QCD 
  Isocat_=1;
  extrasel_="1";
  //if(!scaleSamplesLumi())return 0;
  TH1F* hQCDInc = getQCDInc();
  hQCDInc->SetName("hQCDInc");
 
  //SS Loose Incl QCD 
  Isocat_=-1;
  extrasel_=isocuttxt;
  //if(!scaleSamplesLumi())return 0;
  TH1F* hDataIncLoose = getTotalData();
  hDataIncLoose->SetName("hDataIncLoose");
  TH1F* hMCIncLoose = getTotalMCSM();
  hMCIncLoose->SetName("hMCIncLoose");

  //SS Loose VBF QCD 
  Isocat_=-1;  
  extrasel_=TmpExtrasel+"*"+isocuttxt;
  //if(!scaleSamplesLumi())return 0;
  TH1F* hDataVBFLoose=getTotalData();
  hDataVBFLoose->SetName("hDataVBFLoose");
  TH1F* hMCVBFLoose=getTotalMCSM();
  hMCVBFLoose->SetName("hMCVBFLoose");
  

  char isocuttxtshape[100];
  sprintf(isocuttxtshape,"(0.2<muiso&&muiso<%.3f&&tauisomva>%.3f)",0.5,-0.75);//for shape
  cout<<"Calculating QCD Shape with Mike Method and loose iso cut: "<<isocuttxtshape<<endl;

  //SS Loose VBF QCD 
  Isocat_=-1;  
  extrasel_=TString("(njet>=2)*")+isocuttxtshape;
  //if(!scaleSamplesLumi())return 0;
  TH1F* hDataVBFLooseShape=getTotalData();
  hDataVBFLooseShape->SetName("hDataVBFLooseShape");
  TH1F* hMCVBFLooseShape=getTotalMCSM();
  hMCVBFLooseShape->SetName("hMCVBFLooseShape");
  
  TH1F* hShape=getPlotHisto("hSMQCDShape");

  hShape->Sumw2();
  hShape->Add(hDataVBFLooseShape);
  hShape->Add(hMCVBFLooseShape,-1.);


  //return scale factors to normal
  Isocat_=TmpIsocat;
  extrasel_=TmpExtrasel;
  if(!scaleSamplesLumi())return 0;

  //OS VBF QCD = 1.11 * (SS VBF QCD with loose iso.) * [(SS incl QCD) / ( SS incl QCD with loose iso.)]
  TH1F* h=getPlotHisto("hSMQCD");//new TH1F("hSMQCD","QCD",nbins_,xmin_,xmax_);
  h->Sumw2();
  h->Add(hDataVBFLoose);
  h->Add(hMCVBFLoose,-1.);
  cout<<"QCD sideband integral for datacard : "<< h->Integral()<<endl;

  
  //smear
  TH1F * htmp  = smearHisto(h);
  delete h;
  h = htmp;

  //scale to yield
  cout<<" QCDInc "<<hQCDInc->Integral()<<endl;
  cout<<" DataVBFLoose "<<hDataVBFLoose->Integral()<<endl;
  cout<<" MCVBFLoose "<<hMCVBFLoose->Integral()<<endl;
  cout<<" DataIncLoose "<<hDataIncLoose->Integral()<<endl;
  cout<<" MCIncLoose "<<hMCIncLoose->Integral()<<endl;
  h->Scale(hQCDInc->Integral()/(hDataIncLoose->Integral()-hMCIncLoose->Integral()));
  hShape->Scale(h->Integral()/hShape->Integral());
  delete hDataIncLoose;
  delete hMCIncLoose;
  delete hDataVBFLoose;
  delete hMCVBFLoose;
  delete h;

  Chcat_=ChcatTmp;
  return hShape;
}


TH1F* TauElePlotter::getQCDHCP(){

  char isocuttxt[100];
  sprintf(isocuttxt,"(0.2<muiso&&muiso<0.5&&tauisomva>0.7)");//for normalization
  char isocuttxtshape[100];
  sprintf(isocuttxtshape,"(0.2<muiso&&muiso<0.5&&tauisomva>0.7&&njet20>=2)");//for shape (add mva>0.)
  
  Int_t TmpIsocat=Isocat_;
  TString TmpExtrasel=extrasel_;  
  Int_t ChcatTmp=Chcat_;
  Chcat_=2;

  //SS incl QCD 
  Isocat_=1;
  extrasel_="1";
  TH1F* hQCDInc = getQCDInc();  if(!hQCDInc){cout<<" QCDInc not determined "<<endl; return 0;}   hQCDInc->SetName("hQCDInc");
 
  //SS Loose Incl QCD 
  Isocat_=-1;
  extrasel_=isocuttxt;
  TH1F* hDataIncLoose = getTotalData();  if(!hDataIncLoose){cout<<" Total Data not determined "<<endl; return 0;}   hDataIncLoose->SetName("hDataIncLoose");

  //SS Loose VBF QCD 
  Isocat_=-1;  
  extrasel_=TmpExtrasel+"*"+isocuttxt;
  TH1F* hDataVBFLoose=getTotalData();  if(!hDataVBFLoose){cout<<" Total Data not determined "<<endl; return 0;}   hDataVBFLoose->SetName("hDataVBFLoose");

  //QCD Shape
  Isocat_=-1;  
  extrasel_=isocuttxtshape;
  TH1F* hShape=getTotalData();  if(!hShape){cout<<" hShape not made "<<endl; return 0;}   hShape->SetName("hShape");

  //return scale factors to normal
  Isocat_=TmpIsocat;
  extrasel_=TmpExtrasel;
  Chcat_=ChcatTmp;

  //OS VBF QCD = 1.11 * (SS VBF QCD with loose iso.) * [(SS incl QCD) / ( SS incl QCD with loose iso.)]
  cout<<" QCDInc "<<hQCDInc->Integral()<<endl;
  cout<<" DataVBFLoose "<<hDataVBFLoose->Integral()<<endl;
  cout<<" DataIncLoose "<<hDataIncLoose->Integral()<<endl;
  hShape->Scale(hQCDInc->Integral()*(hDataVBFLoose->Integral()/hDataIncLoose->Integral())/hShape->Integral());

  delete hDataIncLoose;
  delete hDataVBFLoose;
  delete hQCDInc;

  return hShape;


}



//////////////////////////////Plot

bool TauElePlotter::plotInc(TString variable, Int_t nbins, Float_t xmin, Float_t xmax, Int_t Chcat, Int_t Isocat, Int_t MTcat,TString extrasel, TString blindsel, Int_t QCDType, Int_t WJetsType, TString xlabel, TString ylabel,Float_t* legendcoords, int higgs,TString filetag){


  plotvar_=variable;
  nbins_=nbins;
  xmin_=xmin;
  xmax_=xmax;
  Chcat_=Chcat;
  Isocat_=Isocat;
  MTcat_=MTcat;
  extrasel_="1";//reset for multiple plotting
  if(extrasel.CompareTo("")!=0) extrasel_ += TString("*")+extrasel;


  if(!scaleSamplesLumi())return 0;
   
  
  TH1F*hQCD = 0;
  if(Chcat_==1){
    if(QCDType==0) hQCD=getQCDInc();
    if(QCDType==1) hQCD=getQCDIncWJetsShape();
    if(QCDType==2) hQCD=getQCDIncLooseShape();
    if(QCDType==3) hQCD=getQCDMike();
    if(QCDType==4) hQCD=getQCDKeti();
    if(QCDType==5) hQCD=getQCDHCP();
    if(QCDType==6) hQCD=getQCDIncFit();//for 2012
  }
  if(hQCD){
    hQCD->SetLineWidth(1);   hQCD->SetLineColor(1);    hQCD->SetFillColor(QCDColor_);
  } else     cout<<"no QCD determined "<<endl;
  if(hQCD)hQCD->SetName("hQCDplotInc");
  if(hQCD) cout<<"QCD "<<hQCD->Integral()<<endl;
  if(nbins_==0) if(hQCD) makeDensityHisto(hQCD);


  TH1F* hWJetsToLNu=0;
  //Methods using standard WJets sample
  if(WJetsType==0) hWJetsToLNu = getWJetsInc(); 
  if(WJetsType==1) hWJetsToLNu = getSample("WJetsToLNu"); 
  if(WJetsType==2) hWJetsToLNu = getWJetsNJet(); 
  if(WJetsType==3) hWJetsToLNu = getWJetsNJetVBFHCP();
  //if(WJetsType==3) hWJetsToLNu = getWJetsIncShape();
  //if(WJetsType==4) hWJetsToLNu = getWJetsIncShape2012();
  //if(WJetsType==5) hWJetsToLNu = getWJetsInc2012(); 
  if(!hWJetsToLNu){
    cout<<"WJets Background is NULL"<<endl; 
    return 0;
  }
  hWJetsToLNu->SetName("hWJetsToLNuplotInc");
  hWJetsToLNu->SetLineWidth(1);
  hWJetsToLNu->SetLineColor(1);
  hWJetsToLNu->SetFillColor(WJetsColor_);
  cout<<"hWJetsToLNu "<<hWJetsToLNu->Integral()<<endl;
  if(nbins_==0) makeDensityHisto(hWJetsToLNu);  

  TH1F*hTTJets=getTTJetsInc();
  if(!hTTJets)return 0;
  hTTJets->SetName("hTTJetsplotInc");
  hTTJets->SetLineWidth(1);
  hTTJets->SetLineColor(1);
  hTTJets->SetFillColor(TTJetsColor_); 
  cout<<"TTJets "<<hTTJets->Integral()<<endl;
  if(nbins_==0)makeDensityHisto(hTTJets);  

  ///Z->tau tau
  TH1F*hZToTauTau=getZToTauTau();
  if(!hZToTauTau)return 0;
  hZToTauTau->SetName("hZToTauTauplotInc");
  hZToTauTau->SetLineWidth(1);
  hZToTauTau->SetLineColor(1);
  hZToTauTau->SetFillColor(ZTauTauColor_);
  cout<<"ZToTauTau "<<hZToTauTau->Integral()<<endl;
  if(nbins_==0)makeDensityHisto(hZToTauTau);  

  
  TH1F*hEWK=(TH1F*)hWJetsToLNu->Clone("hElectroWeak");

  //combine Di-Bosons
  TH1F*hVV=getDiBoson();
  if(!hVV)return 0;
  hVV->SetName("hVVplotInc");
  if(nbins_==0)makeDensityHisto(hVV); 
  hEWK->Add(hVV);

  //combine ZLJet
  TH1F*hZToLJet=getZToLJetInc();
  if(!hZToLJet)return 0;
  hZToLJet->SetName("hZToLJetplotInc");
  if(nbins_==0)makeDensityHisto(hZToLJet); 
  hEWK->Add(hZToLJet);


  //keep ZEE separate
  TH1F*hZToEE=getZToEEInc();
  if(!hZToEE)return 0;
  hZToEE->SetName("hZToEEplotInc");
  hZToEE->SetLineWidth(1);
  hZToEE->SetLineColor(1);
  hZToEE->SetFillColor(ZMuMuColor_);
  if(nbins_==0)makeDensityHisto(hZToEE); 


  ////////////////////////
  cout<<"Creating Bkg Stack:"<<endl;
  THStack hMCStack("hBkgStack","BkgStack");//dont't set any of the regular histogram properties on the THStack will crash.
  if(hQCD)hMCStack.Add(hQCD,"hist");
  hMCStack.Add(hEWK,"hist");
  hMCStack.Add(hTTJets,"hist");
  hMCStack.Add(hZToEE,"hist");
  hMCStack.Add(hZToTauTau,"hist");


  //create total Background
  TH1F* hBkg=getPlotHisto("hBkg");
  TList* histList= hMCStack.GetHists();
  for(Int_t i=0;i<histList->GetSize();i++){
    hBkg->Add((TH1F*)(histList->At(i)));
  }
  cout<<"Total Bkg "<<hBkg->Integral()<<endl;

  
  //the higgs

  TH1F*hHiggs=0;
  if(higgs>0){
    if(MSSMFlag_){
      hHiggs=getSample("SUSYBB200");
      hHiggs->SetName("hHiggs");
      TH1F*hHiggsGG=getSample("SUSYGG200");
      hHiggs->Add(hHiggsGG);
      hHiggs->Scale(higgs);
      if(nbins_==0)makeDensityHisto(hHiggs); 
      hHiggs->Add(hBkg);
      hHiggs->SetLineColor(1);
      hHiggs->SetLineStyle(2);
      delete hHiggsGG;
    }else {
      hHiggs=getSample("HiggsVBF125");
      hHiggs->SetName("hHiggs");
      TH1F*hHiggsGG=getSample("HiggsGG125");
      hHiggs->Add(hHiggsGG);
      TH1F*hHiggsVH=getSample("HiggsVH125");
      hHiggs->Add(hHiggsVH);
      cout<<"Total Higgs yield : VBF="<<hHiggs->Integral()<<" GG="<<hHiggsGG->Integral()<<" VH="<<hHiggsVH->Integral()<<endl;
      hHiggs->Scale(higgs);
      if(nbins_==0)makeDensityHisto(hHiggs); 
      hHiggs->Add(hBkg);
      hHiggs->SetLineColor(1);
      hHiggs->SetLineStyle(2);
      delete hHiggsGG;
      delete hHiggsVH;
    }
  }

  ////Total Data
  if(blindsel.CompareTo("")!=0) blindsel_=blindsel;
  TH1F* hData=getTotalData();
  if(nbins_==0)makeDensityHisto(hData); 
  blindsel_="1";//blind only around this call otherwise may affect background estimations
  if(!hData){cout<<" Total Data not determined "<<endl; return 0;}

  cout<<"Total Data "<<(int)(hData->Integral())<<endl; 

  //create legend key
  TLegend legend;
  legend.SetFillStyle(0);
  legend.SetFillColor(0);
  legend.SetLineColor(0);
  legend.SetLineWidth(0);
  legend.SetBorderSize(1);
  legend.SetTextAlign(12);
  legend.AddEntry(hData,"Observed","PL");  
  if(hHiggs){
    if(MSSMFlag_)legend.AddEntry(hHiggs,TString("Signal"),"L");
    else legend.AddEntry(hHiggs,TString("")+(long)higgs+" x SM H(125)","L");
  }
  legend.AddEntry(hZToTauTau,"Z#rightarrow#tau^{+}#tau^{-}","F");
  legend.AddEntry(hZToEE,"Z #rightarrow e^{+}e^{-}","f");
  legend.AddEntry(hTTJets,"t#bar{t}","F");
  legend.AddEntry(hEWK,"Electroweak","F");
  if(hQCD)  legend.AddEntry(hQCD,"QCD","F");



//   TString tag;
//   if(filetag.CompareTo("")!=0) tag=plotvar_+"_"+filetag;
//   else{
//     tag=plotvar_;
//     if(extrasel_.CompareTo("1")!=0) tag = tag + extrasel_;
//     if(Isocat_>0) tag=tag+"_Iso"+(long)Isocat_;
//     if(MTcat_>0) tag=tag+"_MT"+(long)MTcat_;
//   }
//   fixFileTag(&tag);  
//   TString filename=outputpath_+"/TauElePlotter_"+tag;

  TString filename=outputpath_+"/"+filetag;
  TCanvas C("C",filename);  
  C.Print(filename+".ps[");


  cout<<" Creating Plot:"<<endl;
  ///////////////////////
  ///Make plot 
  ///////////////////////
  C.Clear();
  hMCStack.Draw("hist");  
  hData->SetTitle("");
  if(hMCStack.GetHistogram()->GetMaximum()<hData->GetMaximum())
    hData->GetYaxis()->SetRangeUser(0,hData->GetMaximum()*1.2);
  if(hMCStack.GetHistogram()->GetMaximum()>hData->GetMaximum())
    hData->GetYaxis()->SetRangeUser(0,hMCStack.GetHistogram()->GetMaximum()*1.2);
  hData->SetStats(0);
  hData->GetXaxis()->SetTitle(xlabel);
  hData->GetYaxis()->SetTitle(ylabel);
  hData->Draw("hist pe");
  hMCStack.Draw("hist same");  
  //////////////////////////
  hData->Draw("hist pe same");//bring Data points back to front
  hBkg->SetFillColor(0);
  hBkg->SetLineColor(1);
  hBkg->Draw("histsame");//draw outline of MC        
  hMCStack.GetHistogram()->Draw("same");//bring axes back to front 
  if(hHiggs)hHiggs->Draw("histsame");
  if(legendcoords){
    legend.SetX1NDC(legendcoords[0]);
    legend.SetX2NDC(legendcoords[1]);
    legend.SetY1NDC(legendcoords[2]);
    legend.SetY2NDC(legendcoords[3]);
  }
  legend.SetTextSize(.04);
  legend.Draw();


  TPaveText title(.155,.91,.9,.999, "NDC");
  title.SetBorderSize(   0 );
  title.SetFillStyle(    0 );
  title.SetTextAlign(   12 );
  title.SetTextSize ( 0.034 ); //do not increase size power on fb will get separated
  title.SetTextColor(    1 );
  title.SetTextFont (   62 );
  title.AddText(plotTitle_);
  title.Draw();



  C.RedrawAxis();
  C.Update();
  C.Print(filename+".ps");  
  C.Print(filename+".png");  
  C.Print(filename+".eps");  
  C.Print(filename+".pdf");  
  C.Print(filename+".C");  
  hData->GetYaxis()->SetRangeUser(0.1,hData->GetMaximum()*100);
  C.Update();
  C.SetLogy(1);
  C.Print(filename+".ps"); 
  C.Print(filename+"_log.png");   
  C.Print(filename+"_log.eps");   
  C.Print(filename+"_log.pdf");   
  C.Print(filename+"_log.C");   
  C.SetLogy(0);

  
  TLine line;


  //make the difference plot  
  TH1F* hDiff=getPlotHisto("hDiff");

  //hDiff->SetStats(0);
  hDiff->GetXaxis()->SetTitle(hData->GetXaxis()->GetTitle());
  hDiff->GetYaxis()->SetTitle("Data - MC");
  hDiff->Add(hData);
  hDiff->Add(hBkg,-1);
  float max=fabs(hDiff->GetMaximum());
  if(fabs(max)<fabs(hDiff->GetMinimum())) max = fabs(hDiff->GetMinimum());
  hDiff->GetYaxis()->SetRangeUser(-max,max);
  C.Clear();
  hDiff->Draw("hist pe");
  line.DrawLine(xmin_,0,xmax_,0);
  C.Print(filename+".ps");  


  //make the ratio plot
  TH1F* hRatio=getPlotHisto("hRatio");

  hRatio->SetStats(0);
  hRatio->GetXaxis()->SetTitle(hData->GetXaxis()->GetTitle());
  hRatio->GetYaxis()->SetTitle("Data/MC");
  hRatio->Add(hData);
  hRatio->Divide(hBkg);
  hRatio->GetYaxis()->SetRangeUser(0,2);
  C.Clear();
  hRatio->Draw("hist pe");
  line.DrawLine(xmin_,1,xmax_,1);
  C.Print(filename+".ps");  

  C.Print(filename+".ps]");
  cout<<"closed ps file"<<endl;


  TFile DiffFile(filename+".root","recreate");

  if(hQCD)hQCD->Write();
  hTTJets->Write();
  hZToTauTau->Write();
  hZToLJet->Write();
  hZToEE->Write();
  hWJetsToLNu->Write();
  hVV->Write();
  hEWK->Write();
  hData->Write();
  hBkg->Write();
  if(hHiggs)hHiggs->Write();
  hDiff->Write();
  hRatio->Write();

  DiffFile.ls();
  DiffFile.Close();

  if(hQCD) delete hQCD;
  delete hTTJets;
  delete hZToTauTau;
  delete hZToLJet;  
  delete hZToEE;
  delete hWJetsToLNu;
  delete hVV;
  delete hEWK;
  delete hData;
  if(hHiggs) delete hHiggs;
  delete hBkg;
  delete hDiff;
  delete hRatio;


  return 1;

}



////////////////////Other stuff

TH1F* TauElePlotter::getWJetsSM(){
  TH1F* h=0;
  float y=0.;
  float ye=0.;
  //samples with low stats at high mT dont apply scale factor
  h=getSample("WJetsToLNu");
  y=h->Integral();
  ye=0;
  for(Int_t b=1;b<=h->GetNbinsX();b++){
    if(h->GetBinContent(b)>0)ye+=h->GetBinError(b)*h->GetBinError(b);
  }
  
  cout<<" WJetsSM : "<<y<<" +- "<<sqrt(ye)<<endl;
  return h;
}


TH1F* TauElePlotter::getQCDMuIsoSM(){
  TString sel="eventweight*(abs(ditaucharge)==0&&0.3<muiso&&muiso<0.5)";
  if(MTcat_==1)  sel += "*(transversemass<30)";
  if(MTcat_==3)  sel += "*(70<transversemass&&transversemass<150)";
  if(MTcat_==13)  sel += "*(60<transversemass&&transversemass<120)";
  if(extrasel_.CompareTo("1")!=0)sel += TString("*")+extrasel_;

  TH1F* h=getPlotHisto("hSMQCD");
 
  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="Data"){
      TH1F*hd=0;//(*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      if(nbins_>0) hd=(*s)->getHistoNtpFile(plotvar_,nbins_,xmin_,xmax_,sel);
      else if(nbinsVariable_>0) hd=(*s)->getHistoNtpFile(plotvar_,nbinsVariable_,xbinsVariable_,sel);
      else { cout<<"binning not recognized "<<endl; return 0;}
      h->Add(hd);
      delete hd;
    }
  }

  h->Scale(QCDMuIsoSideRatio_);

  return h;
}


TH1F* TauElePlotter::getW3Jets(){
  cout<<" calling getW3Jets(): "<<endl;

  //integral of WJets in signal region
  TH1F* hW3JetsLowMT=getSample("W3JetsToLNu");
  hW3JetsLowMT->SetName("hW3JetsLowMT");
  cout<<"hW3JetsLowMT :"<<hW3JetsLowMT->Integral()<<endl;

  //calculate normalization factor
  Int_t tmpMTcat=MTcat_;
  MTcat_=3;//go to high mT with same selections as with plot, cannot relax iso according to Lorenzo
  TH1F* hDataHighMT=getTotalData();
  hDataHighMT->SetName("hDataHighMT");
  cout<<"hDataHighMT :"<<hDataHighMT->Integral()<<endl;
  TH1F* hTTJetsHighMT=getSample("TTJets");
  hTTJetsHighMT->SetName("hTTJetsHighMT");
  cout<<"hTTJetsHighMT :"<<hTTJetsHighMT->Integral()<<endl;
  TH1F* hW3JetsHighMT=getSample("W3JetsToLNu");
  hW3JetsHighMT->SetName("hW3JetsHighMT");
  cout<<"hW3JetsHighMT :"<<hW3JetsHighMT->Integral()<<endl;
  MTcat_=tmpMTcat;

  //for shape relax the isolation in low mT region
  Int_t TmpIsocat=Isocat_;
  Isocat_=-1;
  TString TmpExtrasel=extrasel_; 
  char isocuttxt[100];
  sprintf(isocuttxt,"(muiso<0.1&&tauisomva>%.3f)",-0.75);
  cout<<" using loose iso selection "<<isocuttxt<<endl;
  extrasel_+=TString("*")+isocuttxt;
  TH1F* hW3JetsShape=getSample("W3JetsToLNu");
  hW3JetsShape->SetName("hW3JetsShape");
  cout<<"hW3JetsShape :"<<hW3JetsShape->Integral()<<endl;

  //return to normal
  Isocat_=TmpIsocat;
  extrasel_=TmpExtrasel;

  //smear
  TH1F * htmp  = smearHisto(hW3JetsShape);
  delete hW3JetsShape;
  hW3JetsShape = htmp;


  if(hW3JetsHighMT->Integral()>0&&hW3JetsShape->Integral()>0){
    float HighToLowRatio=hW3JetsLowMT->Integral()/hW3JetsHighMT->Integral();
    cout<<"getW3Jets HighToLowRatio "<<HighToLowRatio<<endl;
    hW3JetsShape->Scale((HighToLowRatio*(hDataHighMT->Integral()-hTTJetsHighMT->Integral()))/hW3JetsShape->Integral());
  }  else {
    cout<<" getW3Jets  Warning hW3JetsHighMT is 0 cannot divide"<<endl;
    hW3JetsShape->Scale(0.);
  }

  delete hDataHighMT;
  delete hTTJetsHighMT;
  delete hW3JetsLowMT;
  delete hW3JetsHighMT;

  
  cout<<"getW3Jets yield: "<<hW3JetsShape->Integral()<<endl;

  return hW3JetsShape;
}




// TH1F* TauElePlotter::getQCDTauIsoSM(){
  
//   TH1F* h=getPlotHisto("hSMQCD");//new TH1F("hSMQCD","SMQCD",nbins_,xmin_,xmax_);

   
//   Int_t TmpIsocat=Isocat_;  
//   Isocat_=2;//switch temporarily while keeping all other categories the same  
//   if(!scaleSamplesLumi())return 0;//need to recalculate WJets correction factors because isolation is different
// 

//   TFile FQCDTauIsoSM(outputpath_+"/FQCDTauIsoSM_"+plotvar_+"_TauIso"+(long)Isocat_+"_MT"+(long)MTcat_+"_SM"+(long)SMcat_+".root","recreate");


//   /////////////////////
//   cout<<"Applying Tau Iso QCD ratio : "<<qcdTauIsoRatio_<<endl;
//   TString tmpextrasel=extrasel_;
//   extrasel_ += TString("*(nditau==1)*")+qcdTauIsoRatio_;//apply  ratio here 

//   TH1F* hData=getTotalData();
//   if(!hData){cout<<" Total Data not determined "<<endl; return 0;}
//   TH1F* hMC=getTotalMCSM();
//   if(!hMC){cout<<" Total Data not determined "<<endl; return 0;}
//   h->Add(hData);
//   h->Add(hMC,-1);
//   hData->SetName("hData"); hData->Write();
//   hMC->SetName("hMC"); hMC->Write();
//   delete hData;
//   delete hMC;
//   //fix the negative bins
//   for(Int_t b=1;b<=nbins_;b++) 
//     if(h->GetBinContent(b)<0.){
//       h->SetBinContent(b,0); h->SetBinError(b,0);
//     }
//   h->SetName("hQCD");h->Write();


// //   //correct the tau pt shape but keep the same yield
// //   Float_t QCDYield=h->Integral();
// //   cout<<"Mean before "<<h->GetMean()<<endl;
// //   h->Clear();
// //   TString tauptshape="*(0.25*(taupt-20))";
// //   extrasel_+=tauptshape;
// //   hData=getTotalData();
// //   if(!hData){cout<<" Total Data not determined "<<endl; return 0;}
// //   hMC=getTotalMCSM();
// //   if(!hMC){cout<<" Total Data not determined "<<endl; return 0;}
// //   h->Add(hData);
// //   h->Add(hMC,-1);
// //   hData->SetName("hDataShape"); hData->Write();
// //   hMC->SetName("hMCShape"); hMC->Write();
// //   delete hData;
// //   delete hMC;
// //   //fix the negative bins
// //   for(Int_t b=1;b<=nbins_;b++) 
// //     if(h->GetBinContent(b)<0.){
// //       h->SetBinContent(b,0); h->SetBinError(b,0);
// //     }
// //   h->Scale(QCDYield/h->Integral());
// //   cout<<"Mean after "<<h->GetMean()<<endl;
// //   h->SetName("hQCDShape");h->Write();
 
//   FQCDTauIsoSM.ls();
//   FQCDTauIsoSM.Close();

//   cout<<"QCDTauIso "<<h->Integral()<<endl;
//   extrasel_=tmpextrasel;
//   ////////////////////////

//   Isocat_=TmpIsocat;//return to normal
//   if(!scaleSamplesLumi())return 0;
// 

//   return h;

// }



TH1F* TauElePlotter::getQCDIsoSM(){
   

  TH1F* h=getPlotHisto("hQCDSM");//new TH1F("hQCD","SMQCD",nbins_,xmin_,xmax_);

  
  Int_t TmpIsocat=Isocat_;  
  Isocat_=-1;  
  TString tmpextrasel=extrasel_;
  
  TString muisocut="(muiso<0.1)";
  TString tauisocut="(tauisodiscmva>=1)";
  TString muantiisocut="(muiso>0.1)";
  TString tauantiisocut="(tauisodiscmva<1)";



//   //QCD From Region B
  TH1F* hB=getPlotHisto("hSMQCDB");//new TH1F("hSMQCDB","SMQCDB",nbins_,xmin_,xmax_);
//   hB->Sumw2();
//   cout<<"Applying Tau Iso QCD ratio : "<<qcdTauIsoRatio_<<endl;
//   extrasel_ = extrasel_+ "*"+muisocut+"*"+tauantiisocut+"*"+qcdTauIsoRatio_;
//   if(!scaleSamplesLumi())return 0;//need to recalculate WJets correction factors because isolation is different
// //   TH1F* hDataB=getTotalData();  if(!hDataB){cout<<" Total Data not determined "<<endl; return 0;}   hDataB->SetName("hDataB");
//   TH1F* hMCB=getTotalMCSM();   if(!hMCB){cout<<" Total Data not determined "<<endl; return 0;}   hMCB->SetName("hMCB");
//   extrasel_ = tmpextrasel;
//   hB->Add(hDataB,1.);
//   hB->Add(hMCB,-1.);
//   cout<<"QCD Region B "<<hDataB->Integral()<<" - "<<hMCB->Integral()<<endl;


//   //QCD From Region C
  TH1F* hC=getPlotHisto("hSMQCDC");//new TH1F("hSMQCC","SMQCC",nbins_,xmin_,xmax_);
//   hC->Sumw2();
//   cout<<"Applying Mu Iso QCD ratio : "<<qcdMuIsoRatio_<<endl;
//   extrasel_ = extrasel_+"*"+muantiisocut+"*"+tauisocut+"*"+qcdMuIsoRatio_;
//   if(!scaleSamplesLumi())return 0;//need to recalculate WJets correction factors because isolation is different
// //   TH1F* hDataC=getTotalData();  if(!hDataC){cout<<" Total Data not determined "<<endl; return 0;}   hDataC->SetName("hDataC");
//   TH1F* hMCC=getTotalMCSM();   if(!hMCC){cout<<" Total Data not determined "<<endl; return 0;}   hMCC->SetName("hMCC");
//   extrasel_ = tmpextrasel;
//   hC->Add(hDataC,1.);
//   hC->Add(hMCC,-1.);
//   Float_t Cerr=0.;
//   for(Int_t b=1;b<=nbins_;b++) Cerr+=hC->GetBinError(b)*hC->GetBinError(b);
//   cout<<"QCD Region C "<<hDataC->Integral()<<" - "<<hMCC->Integral()<<endl;



  //QCD From Region D
  TH1F* hD=getPlotHisto("hSMQCDD");//new TH1F("hSMQCD","SMQCD",nbins_,xmin_,xmax_);
  cout<<"Applying Tau-Mu Iso QCD ratio : "<<qcdTauIsoRatio_+"*"+qcdMuIsoRatio_<<endl;
  extrasel_ = extrasel_+ "*"+muantiisocut+"*"+tauantiisocut+"*"+qcdTauIsoRatio_+"*"+qcdMuIsoRatio_;
  if(!scaleSamplesLumi())return 0;//need to recalculate WJets correction factors because isolation is different
  TH1F* hDataD=getTotalData();  if(!hDataD){cout<<" Total Data not determined "<<endl; return 0;}   hDataD->SetName("hDataD");
  TH1F* hMCD=getTotalMCSM();   if(!hMCD){cout<<" Total Data not determined "<<endl; return 0;}   hMCD->SetName("hMCD");
  extrasel_ = tmpextrasel;
  hD->Add(hDataD,1.);
  hD->Add(hMCD,-1.);
  cout<<"QCD Region D "<<hDataD->Integral()<<" - "<<hMCD->Integral()<<endl;


  //////Determine yield for each region with its error
  Float_t QCDYieldB=hB->Integral();
  Float_t QCDerrB=0.;
  Float_t QCDYieldC=hC->Integral();
  Float_t QCDerrC=0.;
  Float_t QCDYieldD=hD->Integral();
  Float_t QCDerrD=0.;
  for(Int_t b=1;b<=nbins_;b++){
    QCDerrB+=hB->GetBinError(b)*hB->GetBinError(b);
    QCDerrC+=hC->GetBinError(b)*hC->GetBinError(b);
    QCDerrD+=hD->GetBinError(b)*hD->GetBinError(b);
  }


  cout<<"summary of QCD estimates:"<<endl;
  cout<<"QCD Region B "<<QCDYieldB<<" +- "<<sqrt(QCDerrB)<<endl;
  cout<<"QCD Region C "<<QCDYieldC<<" +- "<<sqrt(QCDerrC)<<endl;
  cout<<"QCD Region D "<<QCDYieldD<<" +- "<<sqrt(QCDerrD)<<endl;

//   //for the average make an error weighted average
//   Float_t wsum=(1./QCDerrB+1./QCDerrC+1./QCDerrD);
//   Float_t QCDYield=(QCDYieldB/QCDerrB+QCDYieldC/QCDerrC+QCDYieldD/QCDerrD)/wsum;
//   //Float_t QCDerr=(1./sqrt(QCDerrB)+1./sqrt(QCDerrC)+1./sqrt(QCDerrD))/(1./QCDerrB+1./QCDerrC+1./QCDerrD);
//   Float_t QCDerr=sqrt((QCDerrB*pow((1./QCDerrB)/wsum,2)+QCDerrC*pow((1./QCDerrC)/wsum,2)+QCDerrD*pow((1./QCDerrD)/wsum,2)));

  //for the average make an error weighted average
  Float_t QCDYield=QCDYieldD;
  Float_t QCDerr=QCDerrD;
  
  //   //find the maximum deviation from the mean for systematic estimate:
  float SystErr=0.;
  //   if(fabs(QCDYield-QCDYieldB)>SystErr)SystErr=fabs(QCDYield-QCDYieldB);
  //   if(fabs(QCDYield-QCDYieldC)>SystErr)SystErr=fabs(QCDYield-QCDYieldC);
  //   if(fabs(QCDYield-QCDYieldD)>SystErr)SystErr=fabs(QCDYield-QCDYieldD);
  cout<<"QCDIso: "<<QCDYield<<" +- "<<QCDerr<<" +- "<<SystErr<<endl;

  //////////////////////////////////Shape///////////////////////////////////

  /////Shape taken from D region with fake rate applied
  //   h->Add(hD);
  //   //fix any negative bins
  //   for(Int_t b=1;b<=nbins_;b++) 
  //     if(h->GetBinContent(b)<0.){
  //       h->SetBinContent(b,0); h->SetBinError(b,0);
  //     }



  //QCD Shape from Region D
  cout<<" QCD shape from region D"<<endl;
  extrasel_ = extrasel_+ "*"+muantiisocut+"*"+tauantiisocut;
  if(!scaleSamplesLumi())return 0; //need to recalculate WJets correction factors because isolation is different
  TH1F* hDataShape=getTotalData();  if(!hDataShape){cout<<" Total Data not determined "<<endl; return 0;}   hDataShape->SetName("hDataShape");
  TH1F* hMCShape=getTotalMCSM(); if(!hMCShape){cout<<" Total Data not determined "<<endl; return 0;}   hMCShape->SetName("hMCShape");
  h->Add(hDataShape); delete hDataShape;
  h->Add(hMCShape,-1.); delete hMCShape;
  extrasel_ = tmpextrasel;
  //////////////////////////////////////////////////////////////////////////



  //Apply smearing here, this may change the integral
  cout<<"Applying smearing "<<endl;
  TH1F * hsmeared = smearHisto(h);
  delete h;
  h=hsmeared;

  //Normalize to the yield
  h->Scale(QCDYield/h->Integral());
  
  //Save the intermediate histograms in a root file
  TString filetag = TString("FQCDIsoSM_")+plotvar_+"_MT"+(long)MTcat_+"_"+extrasel_;
  fixFileTag(&filetag);
  TFile FQCDIsoSM(outputpath_+"/"+filetag+".root","recreate");
//   hDataB->Write(); delete hDataB;
//   hMCB->Write();   delete hMCB;
//   hDataC->Write(); delete hDataC;
//   hMCC->Write();   delete hMCC;
  hDataD->Write(); delete hDataD;
  hMCD->Write();   delete hMCD;
  h->Write();
  FQCDIsoSM.ls();
  FQCDIsoSM.Close();
  

  delete hB;
  delete hC;
  delete hD;

  /////////return to normal
  Isocat_=TmpIsocat;
  extrasel_=tmpextrasel;
  if(!scaleSamplesLumi())return 0;

  
  return h;

}



TH1F* TauElePlotter::getWJetsTauIsoSM(){
  
  //1.normalize WJets MC Anti-Iso sample at high MT 
  //2.apply ratio to predict the yield in the Iso sample

  TString tmpextrasel=extrasel_;
  Int_t TmpIsocat=Isocat_;  

  //switch temporarily while keeping all other categories the same  
  Isocat_=2;
  extrasel_ += "*(muiso<0.1)";//
  if(!scaleSamplesLumi())return 0;

  //get the shape from the anti-iso sample without the fake rate:
  cout<<"WJets shape obtained from anti-iso sample without fake rate"<<endl;
  TH1F* hShape=getWJetsInc();
  TH1F * h = smearHisto(hShape);
  delete hShape;

  //get the yield by applying the fake rate
  cout<<"Applying Tau Iso WJets ratio : "<<wjetsTauIsoRatio_<<endl;
  extrasel_ = extrasel_+ "*"+wjetsTauIsoRatio_;//
  TH1F* hW=getWJetsInc();
  h->Scale(hW->Integral()/h->Integral());
  delete hW;

  //return to normal
  extrasel_=tmpextrasel;
  Isocat_=TmpIsocat;
  if(!scaleSamplesLumi())return 0;

  float yielder=0.;
  for(Int_t b=1;b<=h->GetNbinsX();b++){
    yielder+=h->GetBinError(b)*h->GetBinError(b);
  }

  cout<<"WJetsTauIso : "<<h->Integral()<<" +- "<<sqrt(yielder)<<endl;
  return h;

}



// ///////////////////////////////////Fake Rate Estimations//////////////////////////////////////////
// void TauElePlotter::plotIsoFakeRate(TString variable, Int_t nbins, Float_t xmin, Float_t xmax, TString extrasel, TString IsoSel, Float_t ymax,Bool_t log){
  
//   plotvar_=variable;
//   nbins_=nbins;
//   xmin_=xmin;
//   xmax_=xmax;
//   Isocat_=-1;
//   if(extrasel!="")extrasel_=extrasel_+"*"+extrasel;//something like (njet==0)

//   TString filetag=plotvar_+extrasel_;
//   fixFileTag(&filetag);

 
//   TCanvas C("C");
//   TString filename = outputpath_ + "/TauElePlotterIsoFakeRate_"+filetag;
//   C.Print(filename+".ps[");


//   /////////Anti-Isolated taus
//   TString tmpextrasel=extrasel_;
//   extrasel_=extrasel_+"*(!"+IsoSel+")";
//   if(!scaleSamplesLumi())return;
//   TH1F* hData=getTotalDataSS();
//   if(!hData){cout<<" Total Data not determined "<<endl; return;}
//   TH1F* hMC=getTotalMCSMSS();
//   if(!hMC){cout<<" Total MC not determined "<<endl; return;}  
//   extrasel_=tmpextrasel;

//   C.Clear();
//   hData->Draw("pe");
//   hMC->Draw("hist same");
//   C.Print(filename+".ps");

//   TH1F* hA=getPlotHisto("hDiffAnti");//new TH1F("hDiffAnti","",nbins_,xmin_,xmax_);
//   hA->Add(hData);
//   hA->Add(hMC,-1);
//   delete hData; delete hMC;


//   /////////////Isolated taus
//   extrasel_=extrasel_+"*"+IsoSel;
//   if(!scaleSamplesLumi())return;
//   hData=getTotalDataSS();
//   if(!hData){cout<<" Total Data not determined "<<endl; return;}
//   hMC=getTotalMCSMSS();
//   if(!hMC){cout<<" Total MC not determined "<<endl; return;}

//   C.Clear();
//   hData->Draw("pe");
//   hMC->Draw("hist same");
//   C.Print(filename+".ps");

//   TH1F* hI=getPlotHisto("hDiffIso");//new TH1F("hDiffIso","",nbins_,xmin_,xmax_);
//   hI->Add(hData);
//   hI->Add(hMC,-1);
//   delete hData; delete hMC;
 
//   C.Clear();
//   C.SetLogy(1);
//   hA->Draw("pe");
//   hI->Draw("pesame");
//   C.Print(filename+".ps");
//   C.SetLogy(0);

//   //average ratio
//   float r=hI->Integral()/hA->Integral();
//   float re=r*sqrt(1./hI->Integral() + 1./hA->Integral());
//   cout<<" Ratio = "<<r<<" +- "<<re<<endl;


//   ////Calculate the ratio as a function of the variable
//   TH1F* hR=getPlotHisto("hRatio");//new TH1F("hRatio","",nbins_,xmin_,xmax_);
//   hR->Add(hI);
//   hR->Divide(hA);
//   delete hA; delete hI;

//   C.Clear();
//   C.SetLogy(log);
//   delete hR->FindObject("stats");
//   hR->GetYaxis()->SetRangeUser(log ? 0.001 : 0,ymax);
//   hR->GetXaxis()->SetTitle(plotvar_);
//   hR->GetYaxis()->SetTitle("ratio");
//   hR->SetTitle("");
//   hR->Draw("pe");
//   C.Print(filename+".ps");


//   cout.precision(3);
//   cout<<"(";
//   Int_t b=1;
//   while(hR->GetBinContent(b)>0&&b<=hR->GetNbinsX()){
//     cout<<"("<<hR->GetBinLowEdge(b)<<"<"<<plotvar_<<"&&"<<plotvar_<<"<="<<hR->GetBinLowEdge(b)+hR->GetBinWidth(b)<<")*";
//     cout<<hR->GetBinContent(b)<<"+";
//     b++;
//   }
//   cout<<")"<<endl;  


//   ///save the ratio histo to a root file:
//   TFile FRatio(filename+".root","recreate");
//   hR->Write();
//   FRatio.ls();
//   FRatio.Close();
  

//   delete hR;

//   C.Print(filename+".ps]");

// }


void TauElePlotter::plotTauFakeRateWJets(TString variable, Int_t nbins, Float_t xmin, Float_t xmax, TString extrasel, Float_t ymax,Bool_t log){
  
  //Ratio of Isolated/Anti-Isolated taus using the the high mT region
  //-Should be computed at inclusive level
  //-Should be computed with OS samples only (SS is different)

  plotvar_=variable;
  nbins_=nbins;
  xmin_=xmin;
  xmax_=xmax;
 
  MTcat_=-1;//dont use this because need to make sure it refers to the proper MET 
  if(extrasel!="")extrasel_=extrasel_+"*"+extrasel;

  TString filetag=plotvar_+extrasel_;
  fixFileTag(&filetag);

 
  TCanvas C("C");
  TString filename = outputpath_ + "/TauElePlotterTauFakeRateWJets_"+filetag;
  C.Print(filename+".ps[");


  /////////Anti-Isolated taus
  Isocat_=2;
  if(!scaleSamplesLumi())return;

  TH1F* hData=getTotalData();
  if(!hData){cout<<" Total Data not determined "<<endl; return;}

  TH1F* hMC=getPlotHisto("hMCAnti");//new TH1F("hMCAnti","",nbins_,xmin_,xmax_);
  TH1F* hZ=getZToTauTau(); hMC->Add(hZ); delete hZ;
  TH1F* hTT=getSample("TTJets"); hMC->Add(hTT); delete hTT;
 
  C.Clear();
  hData->Draw("pe");
  hMC->Draw("hist same");
  C.Print(filename+".ps");

  TH1F* hA=getPlotHisto("hDiffAnti");//new TH1F("hDiffAnti","",nbins_,xmin_,xmax_);
  hA->Add(hData); delete hData; 
  hA->Add(hMC,-1); delete hMC;

  C.Clear();
  hA->Draw("pe");
  C.Print(filename+".ps");


  /////////////Isolated taus
  Isocat_=1;
  if(!scaleSamplesLumi())return;
 
  hData=getTotalData();
  if(!hData){cout<<" Total Data not determined "<<endl; return;}

  hMC=getPlotHisto("hMCIso");//new TH1F("hMCIso","",nbins_,xmin_,xmax_);
  hZ=getZToTauTau(); hMC->Add(hZ); delete hZ;
  hTT=getSample("TTJets"); hMC->Add(hTT); delete hTT;


  C.Clear();
  hData->Draw("pe");
  hMC->Draw("hist same");
  C.Print(filename+".ps");

  TH1F* hI=getPlotHisto("hDiffIso");//new TH1F("hDiffIso","",nbins_,xmin_,xmax_);
  hI->Add(hData);delete hData;
  hI->Add(hMC,-1);delete hMC;
  
  C.Clear();
  hI->Draw("pe");
  C.Print(filename+".ps");

  //average ratio
  float r=hI->Integral()/hA->Integral();
  float re=r*sqrt(1./hI->Integral() + 1./hA->Integral());
  cout<<" Ratio = "<<r<<" +- "<<re<<endl;


  ////Calculate the ratio as a function of the variable
  TH1F* hR=getPlotHisto("hRatio");//new TH1F("hRatio","",nbins_,xmin_,xmax_);
  hR->Add(hI); 
  hR->Divide(hA); 

  C.Clear();
  C.SetLogy(log);
  delete hR->FindObject("stats");
  hR->GetYaxis()->SetRangeUser(log ? 0.001 : 0,ymax);
  hR->GetXaxis()->SetTitle(plotvar_);
  hR->GetYaxis()->SetTitle("ratio");
  hR->SetTitle("");
  hR->Draw("pe");
  C.Print(filename+".ps");


  cout.precision(3);
  cout<<"(";
  Int_t b=1;
  while(hR->GetBinContent(b)>0&&b<=hR->GetNbinsX()){
    cout<<"("<<hR->GetBinLowEdge(b)<<"<"<<plotvar_<<"&&"<<plotvar_<<"<="<<hR->GetBinLowEdge(b)+hR->GetBinWidth(b)<<")*"<<hR->GetBinContent(b)<<"+";
    b++;
  }
  cout<<")"<<endl;  



  ///save the ratio histo to a root file:
  TFile FRatio(filename+".root","recreate");
  hI->Write();
  hA->Write();
  hR->Write();
  FRatio.ls();
  FRatio.Close();
  
  delete hI;
  delete hA; 
  delete hR;

  C.Print(filename+".ps]");

}



void TauElePlotter::plotQCDSSOSRatio(){

  plotvar_="muiso";
  nbins_=7;
  xmin_=0;
  xmax_=0.7;
  Isocat_=-1;
  MTcat_=1;
  Chcat_=2;
  extrasel_="(muiso>0.2&&tauisomva>-1.0)";
  scaleSamplesLumi();

  TCanvas C("plotQCDSSOSRatio");

  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps[");
  

  TH1F* hDataSS=getTotalData();
  hDataSS->SetTitle("");
  hDataSS->GetYaxis()->SetTitle("Events / 0.1 ");
  hDataSS->GetXaxis()->SetTitle("electron rel. isolation ");


  TH1F* HMCSS=getZToTauTau(); 
  HMCSS->SetTitle("HMCSS");
  TH1F* HTTSS=getTTJetsInc(); 
  HMCSS->Add(HTTSS); delete HTTSS;
  TH1F* HWSS=getWJetsInc(); 
  HMCSS->Add(HWSS); delete HWSS;
  
  C.Clear();
  hDataSS->Draw("histpe");
  HMCSS->Draw("histsame");
  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps");
  
  hDataSS->Add(HMCSS,-1);
  delete HMCSS;

  Chcat_=1;
  ////////////////////////////
  TH1F* hDataOS=getTotalData();
  hDataOS->SetTitle("");
  hDataOS->GetYaxis()->SetTitle("Events / 0.1 ");
  hDataOS->GetXaxis()->SetTitle("electron rel. isolation ");
  
  TH1F* HMC=getZToTauTau(); 
  HMC->SetTitle("HMC");
  TH1F* HTT=getTTJetsInc(); 
  HMC->Add(HTT); delete HTT;
  TH1F* HW=getWJetsInc(); 
  HMC->Add(HW); delete HW;

  C.Clear();
  hDataOS->Draw("histpe");
  HMC->Draw("histsame");
  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps");

  hDataOS->Add(HMC,-1);
  delete HMC;

  


  TLegend legend;
  legend.SetFillStyle (0);
  legend.SetFillColor (0);
  legend.SetBorderSize(0);
  legend.AddEntry(hDataOS,"OS QCD","L");
  legend.AddEntry(hDataSS,"SS QCD","P");  
  legend.SetX1NDC(.5);
  legend.SetX2NDC(.9);
  legend.SetY1NDC(.2);
  legend.SetY2NDC(.4);


  C.Clear();
  hDataOS->SetTitle("");
  hDataOS->GetYaxis()->SetTitle("Events / 0.1 ");
  hDataOS->GetXaxis()->SetTitle("electron rel. isolation ");
  hDataOS->Draw("hist");
  hDataSS->Draw("histpesame");
  legend.Draw();
  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps");

  //plot ratio
  hDataOS->Divide(hDataSS);
  C.Clear();
  hDataOS->GetYaxis()->SetRangeUser(0,1.2);
  hDataOS->GetYaxis()->SetTitle("OS / SS ");
  hDataOS->Draw("histpe");
  TLine line;
  line.DrawLine(xmin_,1,xmax_,1);
  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps");

  //Fit to ratio
  //TF1 F1("F1","[0]+[1]*x",xmin_,xmax_);
  TF1 F1("F1","[0]",xmin_,xmax_);
  F1.SetLineColor(2);
  hDataOS->Fit(&F1);
  C.Clear();
  hDataOS->Draw("histpe");
  F1.Draw("same");
  line.DrawLine(xmin_,1,xmax_,1);
  char fitres[100];
//  sprintf(fitres,"(%.2f +- %.2f) - (%.2f +- %.2f)*x",F1.GetParameter(0),F1.GetParError(0),fabs(F1.GetParameter(1)),F1.GetParError(1));
  sprintf(fitres,"(%.3f +- %.3f)",F1.GetParameter(0),F1.GetParError(0));
  TLatex text; text.SetTextSize(0.05); text.SetTextColor(2);
  text.DrawTextNDC(.4,.5,fitres);
  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps");

  C.Print("TauMuPlotter_plotQCDSSOSRatio.ps]");

  delete hDataSS;
  delete hDataOS;
}



bool TauElePlotter::printRawYields(TString selection){
  
  Float_t totalData=0;
  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="Data"){
      TH1F*hmass=(TH1F*)((*s)->getHistoNtpFile("ditaumass",100,0,1000,selection.Data()));
      if(!hmass){cout<<" no histo found for "<<(*s)->GetName()<<endl; return 0;}
      cout<<hmass->GetName()<<" "<<(int)(hmass->Integral(0,hmass->GetNbinsX()+1))<<endl;
      totalData+=hmass->Integral(0,hmass->GetNbinsX()+1);
      delete hmass;
    }
  }
  cout<<"Total Data  = "<<(int)(totalData)<<endl;

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="MC"){
      TH1F*hmass=(TH1F*)((*s)->getHistoNtpFile("ditaumass",100,0,1000,selection.Data()));
      if(!hmass){cout<<" no histo found for "<<(*s)->GetName()<<endl; return 0;}
      cout<<hmass->GetName()<<" "<<(int)(hmass->Integral(0,hmass->GetNbinsX()+1))<<endl;
      delete hmass;
    }
  } 

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="MCCat"){
      TH1F*hmass=(TH1F*)((*s)->getHistoNtpFile("ditaumass",100,0,1000,selection.Data()));
      if(!hmass){cout<<" no histo found for "<<(*s)->GetName()<<endl; return 0;}
      cout<<hmass->GetName()<<" "<<(int)(hmass->Integral(0,hmass->GetNbinsX()+1))<<endl;
      delete hmass;
    }
  }

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="Embedded"){
      TH1F*hmass=(TH1F*)((*s)->getHistoNtpFile("ditaumass",100,0,1000,selection.Data()));
      if(!hmass){cout<<" no histo found for "<<(*s)->GetName()<<endl; return 0;}
      cout<<hmass->GetName()<<" "<<(int)(hmass->Integral(0,hmass->GetNbinsX()+1))<<endl;
      delete hmass;
    }
  }  

  for( std::vector<Sample*>::const_iterator s=samples_.begin(); s!=samples_.end(); ++s){
    if((*s)->getDataType()=="Signal"){
      TH1F*hmass=(TH1F*)((*s)->getHistoNtpFile("ditaumass",100,0,1000,selection.Data()));
      if(!hmass){cout<<" no histo found for "<<(*s)->GetName()<<endl; return 0;}
      cout<<hmass->GetName()<<" "<<(int)(hmass->Integral(0,hmass->GetNbinsX()+1))<<endl;
      delete hmass;
    }
  }
  

  return 1;
}





TH1F* TauElePlotter::smearHisto(TH1F* h){
  if(!h){
    cout<<" smearHisto : histo is NULL"<<endl;
    return 0;
  }

 
  TH1F* hs=0;
 
  if(smearHistoRes_==0.){//just copy
    hs=(TH1F*)h->Clone(TString(h->GetName())+"smeared");
    cout<<"smearHistoRes is 0 returning the same histo"<<endl;
  }else {
    hs=new TH1F(TString(h->GetName())+"smeared",h->GetTitle(),h->GetXaxis()->GetNbins(),h->GetXaxis()->GetXmin(),h->GetXaxis()->GetXmax());
    TF1 gaus("gauss","[0]*exp(-0.5*(x-[1])**2/[2]**2)",h->GetXaxis()->GetXmin(),h->GetXaxis()->GetXmax());
    gaus.SetParameter(2,smearHistoRes_);

    for(Int_t b=1;b<=h->GetXaxis()->GetNbins();b++){
      gaus.SetParameter(0,h->GetBinContent(b));
      gaus.SetParameter(1,h->GetBinCenter(b));
      for(Int_t bs=1;bs<=h->GetXaxis()->GetNbins();bs++){
        hs->AddBinContent(bs,gaus.Eval(hs->GetBinCenter(bs)));
      }
    }
    for(Int_t bs=1;bs<=h->GetXaxis()->GetNbins();bs++){
      hs->SetBinError(bs,0.);//not sure this is necessary
    }
    
    hs->Scale(h->Integral()/hs->Integral());//make sure the output histo has the same integral
  }
  
  return hs;
}


void TauElePlotter::fixFileTag(TString * filetag){

  for(Int_t l=0;l<filetag->Sizeof();l++){//fix the variable name to work with the file name
    if(TString((*filetag)[l])=="(") filetag->Replace(l,1,"_");
    if(TString((*filetag)[l])==")") filetag->Replace(l,1,"_");
    if(TString((*filetag)[l])=="*") filetag->Replace(l,1,"X");
    if(TString((*filetag)[l])=="=") filetag->Replace(l,1,"Q");
    if(TString((*filetag)[l])=="<") filetag->Replace(l,1,"L");
    if(TString((*filetag)[l])==">") filetag->Replace(l,1,"M");
    if(TString((*filetag)[l])=="&") filetag->Replace(l,1,"A");
    if(TString((*filetag)[l])=="+") filetag->Replace(l,1,"P");
    if(TString((*filetag)[l])=="-") filetag->Replace(l,1,"N");
    if(TString((*filetag)[l])=="!") filetag->Replace(l,1,"n");
    if(TString((*filetag)[l])=="%") filetag->Replace(l,1,"p");
    if(TString((*filetag)[l])=="^") filetag->Replace(l,1,"t");
  }

}



