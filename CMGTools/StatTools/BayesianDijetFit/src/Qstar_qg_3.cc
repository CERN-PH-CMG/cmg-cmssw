/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "StatTools/BayesianDijetFit/interface/Qstar_qg_3.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 


#include <math.h> 
#include "TH1D.h"
#include "TFile.h"
#include "TMath.h" 
#include "TCanvas.h"

#include <string>

#include "StatTools/BayesianDijetFit/interface/LineShapeDensityPdf.h"


//--------------------------------------------------------------------
//  The main constructor.
//--------------------------------------------------------------------
Qstar_qg_3::Qstar_qg_3(const char *name, const char *title, 
                       RooAbsReal& _mjj,
		       RooAbsReal& _jes,
		       RooAbsReal& _jer,
                       RooAbsReal& _mass, RooAbsReal& iResonance) :
  RooAbsPdf(name,title), 
  mjj("mjj","Observable",this,_mjj),
  jes("jes","Jet Energy Scale",this,_jes),
  jer("jer","Jet Energy Resolution",this,_jer),
  mass("mass","Resonance Mass",this,_mass)
{ 
//  std::cout << "iResonance = " << iResonance << std::endl;

  double m0[ N_MASS_POINTS ];
  for(int i=0; i<N_MASS_POINTS; i++) {
    m0[i]=INIT_MASS+i*MASS_STEPS;
  }
  
  int bin_cut = TMath::Abs((M_CUT-SHAPE_BINS_MIN)/SHAPE_BINS_STEPS)+1;

  int uR = TMath::Abs(iResonance.getVal());

  string stitle("");

  switch (uR){

  case 11: 
    stitle = string("RSGraviton_ak5_GGtoGG_fat30");
     break;
  case 12:   
    stitle = string("RSGraviton_ak5_QQtoQQ_fat30");
     break;
  case 13:   
    stitle = string("Qstar_ak5_fat30"); 
     break;
  default:
    std::cout << "Nothing would crash" << std::endl; 
    break;
  }
 
  string sout("Resonance_Shapes"); sout = sout + "_" + stitle + ".root";


  TFile * output = new TFile(sout.c_str(),"RECREATE");

  TH1D* eff = new TH1D("Efficiency", "cur efficiency at 890 GeV", N_MASS_POINTS-1, INIT_MASS-MASS_STEPS/2, INIT_MASS+(N_MASS_POINTS-1)*MASS_STEPS-MASS_STEPS/2);

  for (int j = 0; j < N_MASS_POINTS; j++) {
    mass_points[j] = m0[j];
    double resmass = m0[j];
    std::cout << "Generating histogram for resonance mass = " << resmass << std::endl;
    char * histname = new char[100];
    sprintf (histname,"h_qstar_%d", (int)(resmass) );

    //--- Make the shape for this resonance mass.
    LineShapeDensity_pdf(resmass,  uR);

    // make the histograms
    hist[j]=new TH1D(histname, stitle.c_str(), N_SHAPE_BINS, SHAPE_BINS_MIN, SHAPE_BINS_MIN+N_SHAPE_BINS*SHAPE_BINS_STEPS);
    hist_cdf[j]=new TH1D(TString(histname)+"_cdf", stitle.c_str(), N_SHAPE_BINS, SHAPE_BINS_MIN, SHAPE_BINS_MIN+N_SHAPE_BINS*SHAPE_BINS_STEPS);


    for(int i=1; i<=N_SHAPE_BINS; i++) {
      double mss = hist[j]->GetBinCenter(i);
      double prob = FastQstarBinnedProb(mss);
      hist[j]->SetBinContent(i, prob);
    }
    for(int i=1; i<=N_SHAPE_BINS; i++) {
      if (hist[j]->GetBinContent(i)<0.0) hist[j]->SetBinContent(i,0.0);
    }
    // re-normalize the histogram
    double integral=hist[j]->GetSumOfWeights()*SHAPE_BINS_STEPS;
    hist[j]->Scale(1/integral);

    // compute the cdf
    for(int i=1; i<=N_SHAPE_BINS; i++) {
      double prev=hist_cdf[j]->GetBinContent(i-1);
      double curr=hist[j]->GetBinContent(i)*SHAPE_BINS_STEPS;
      hist_cdf[j]->SetBinContent(i, prev+curr);
    }

    cout <<"bin_cut is = " << bin_cut << " min val at this bin is " << hist_cdf[j]->GetBinLowEdge(bin_cut) << " at mass " << resmass << " the efficiency is " << 1-hist_cdf[j]->GetBinContent(bin_cut) << endl;

    eff->SetBinContent(j+1, 1-hist_cdf[j]->GetBinContent(bin_cut));

    //--- Save all histograms, for backup.
    output->cd(); 

     hist[j]->Write();
    hist_cdf[j]->Write();
  }

  output->cd(); 
  eff->Write();

 

  return;
} 


//--------------------------------------------------------------------
// Copy constructor
//--------------------------------------------------------------------
Qstar_qg_3::Qstar_qg_3(const Qstar_qg_3& other, const char* name) :  
  RooAbsPdf(other,name), 
  mjj("mjj",this,other.mjj),
  jes("jes",this,other.jes),
  jer("jer",this,other.jer),
  mass("mass",this,other.mass)
{ 
  // Er, we should have something in there too...
  for (int j = 0; j < N_MASS_POINTS; j++) {
    mass_points[j] = other.mass_points[j];
    hist[j] = (TH1D*) other.hist[j]->Clone();
    hist_cdf[j] = (TH1D*) other.hist_cdf[j]->Clone();
  }
} 

Int_t Qstar_qg_3::findHistFast( double m ) const
{
  double val=(m-INIT_MASS)/MASS_STEPS+0.001;
  return static_cast<int>(val);
}

Double_t Qstar_qg_3::interpolate(Double_t mass, Double_t* histarray) const
{
  double binfloat=(mass-SHAPE_BINS_MIN)/SHAPE_BINS_STEPS;
  int binint=static_cast<int>(binfloat);
  int binlo, binhi;
  double frac;
  if(binfloat-binint<0.5) {
    binlo=binint-1;
    binhi=binint;
    frac=binfloat-binint+0.5;
  } else {
    binlo=binint;
    binhi=binint+1;
    frac=binfloat-binint-0.5;
  }
  if(binlo<0) return histarray[0];
  if(binhi>=N_SHAPE_BINS) return histarray[N_SHAPE_BINS-1];
  return histarray[binlo]*(1-frac)+histarray[binhi]*frac;
}

Double_t Qstar_qg_3::evaluate() const 
{ 
  Int_t j = findHistFast( mass );
  return interpolate(jes*(jer*(mjj-mass)+mass), hist[j]->GetArray());
}


Int_t Qstar_qg_3::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{ 
  //  if (matchArgs(allVars,analVars,mjj)) return 1 ; 
  return 0 ;
} 


Double_t Qstar_qg_3::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code==1);
  Double_t *histarray=hist_cdf[findHistFast(mass)]->GetArray();
  double xmin = mjj.min(rangeName);
  double xmax = mjj.max(rangeName);
  double xminprime = jes*(jer*(xmin-mass)+mass);
  double xmaxprime = jes*(jer*(xmax-mass)+mass);
  double lo = interpolate(xminprime, histarray);
  double hi = interpolate(xmaxprime, histarray);

  //  if(mjj.min(rangeName)<230 && mjj.max(rangeName)>3140) {
  //    hi=histarray[N_SHAPE_BINS-1];
  //    lo=histarray[0];
  //  }

  //  std::cout << "mjj.min=" << xmin << "; mjj.max=" << xmax
  //	    << "; jes=" << jes << "; jer=" << jer << "; mass=" << mass << std::endl;
  //  std::cout << "Computing integral from " << xminprime << " to " << xmaxprime << std::endl;
  //  std::cout << "hi=" << hi << "; lo=" << lo << "; integral=" << (hi-lo) << std::endl;
  //  std::cout << std::endl;
  
  return (hi-lo);
}



Int_t Qstar_qg_3::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const 
{ 
  if (matchArgs(directVars,generateVars,mjj)) return 1 ;
  return 0 ; 
} 



void Qstar_qg_3::generateEvent(Int_t code) 
{ 
  assert(0) ; 
  return; 
} 

ClassImp(Qstar_qg_3)
